import streamlit as st
import pandas as pd
import os
from PIL import Image
from sklearn.neural_network import MLPClassifier, MLPRegressor
from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score
from sklearn.tree import DecisionTreeClassifier, DecisionTreeRegressor
from sklearn.svm import SVR, SVC
from sklearn.ensemble import (
    RandomForestClassifier,
    GradientBoostingClassifier,
    RandomForestRegressor,
    GradientBoostingRegressor,
)
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
import numpy as np
import altair as alt
import joblib
from sklearn.metrics import confusion_matrix, accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression, LinearRegression
from sklearn.preprocessing import (
    StandardScaler,
    MinMaxScaler,
    OrdinalEncoder,
    LabelEncoder,
)
from sklearn.svm import SVR, SVC
from sklearn.ensemble import (
    RandomForestClassifier,
    GradientBoostingClassifier,
    RandomForestRegressor,
    GradientBoostingRegressor,
)
import matplotlib.pyplot as plt
import seaborn as sns
from streamlit import session_state as _state

st.set_page_config(layout="wide")

def main():
    pages = {
        "–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞": page_first,
        "–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö": page_second,
        "–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö": page_third,
        "–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞": page_forth,
        "–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –º–æ–¥–µ–ª–∏": page_fifth,
    }

    st.sidebar.title("iQuat‚ö°")



    page = st.sidebar.radio("–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥—Ö–æ–¥—è—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É", tuple(pages.keys()))

    pages[page]()


def page_first():
    col1, col2, col3 = st.columns(3)
    with col2:
        st.title("iQuat Model Trainer")


    st.write(
        """
            –≠—Ç–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞ –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—É—é –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–æ–≤ –¥–∞–Ω–Ω—ã—Ö, –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–µ–π –∏ —ç–Ω—Ç—É–∑–∏–∞—Å—Ç–æ–≤ –≤ —Å—Ñ–µ—Ä–µ –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è, 
            –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö –Ω–∞–±–æ—Ä–æ–≤ –¥–∞–Ω–Ω—ã—Ö, –≤—ã–±–æ—Ä–∞ –∏ –æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–µ–π –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è, –∞ 
            —Ç–∞–∫–∂–µ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏ –æ—Ü–µ–Ω–∫–∏ –º–µ—Ç—Ä–∏–∫. –¶–µ–ª—å —Å–∞–π—Ç–∞ - —Å–¥–µ–ª–∞—Ç—å –ø—Ä–æ—Ü–µ—Å—Å –∞–Ω–∞–ª–∏–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏ –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è 
            –±–æ–ª–µ–µ –¥–æ—Å—Ç—É–ø–Ω—ã–º –∏ –∏–Ω—Ç—É–∏—Ç–∏–≤–Ω–æ –ø–æ–Ω—è—Ç–Ω—ã–º –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Ä–∞–∑–Ω–æ–≥–æ —É—Ä–æ–≤–Ω—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏, —É—Å–∫–æ—Ä—è—è –Ω–∞—É—á–Ω—ã–µ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –∏ 
            —Ä–∞–∑—Ä–∞–±–æ—Ç–∫—É –ø—Ä–æ–¥—É–∫—Ç–æ–≤. 
        """
    )

    st.subheader("–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç:")

    current_script_dir = os.path.dirname(os.path.abspath(__file__))
    algo_path = Image.open(os.path.join(current_script_dir, "Algorithm.png"))

    st.image(algo_path, caption="–ê–ª–≥–æ—Ä–∏—Ç–º —Å–∞–π—Ç–∞")

    st.subheader("–ó–∞—á–µ–º?")
    st.write(
        """
            1. **–î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å:** –°–Ω–∏–∂–∞–µ—Ç –±–∞—Ä—å–µ—Ä—ã –¥–ª—è –≤—Ö–æ–¥–∞ –≤ –º–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ, –¥–µ–ª–∞—è –µ–≥–æ –¥–æ—Å—Ç—É–ø–Ω—ã–º —à–∏—Ä–æ–∫–æ–π –∞—É–¥–∏—Ç–æ—Ä–∏–∏.
            2. **–ü—Ä–∏–Ω—è—Ç–∏–µ —Ä–µ—à–µ–Ω–∏–π:** –û–±–ª–µ–≥—á–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å –ø—Ä–∏–Ω—è—Ç–∏—è –æ–±–æ—Å–Ω–æ–≤–∞–Ω–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π –≤ –±–∏–∑–Ω–µ—Å–µ –∏ –Ω–∞—É–∫–µ, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—è –≥–ª—É–±–æ–∫–∏–π –∞–Ω–∞–ª–∏–∑ –¥–∞–Ω–Ω—ã—Ö.
            3. **–û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ:** –ü–æ–º–æ–≥–∞–µ—Ç –≤ –æ–±—É—á–µ–Ω–∏–∏ –∏ —Ä–∞–∑–≤–∏—Ç–∏–∏ –Ω–∞–≤—ã–∫–æ–≤ –≤ –æ–±–ª–∞—Å—Ç–∏ –∞–Ω–∞–ª–∏–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏ –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è.
            4. **–†–µ—à–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º:** –ü—Ä–µ–¥–ª–∞–≥–∞–µ—Ç —Ä–µ—à–µ–Ω–∏—è –¥–ª—è —Ä–µ–∞–ª—å–Ω—ã—Ö –∑–∞–¥–∞—á, –∏—Å–ø–æ–ª—å–∑—É—è —Å–∏–ª—É –¥–∞–Ω–Ω—ã—Ö –∏ –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è.
        """
    )



def page_second():
    st.title("–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö")
    st.warning("–ü—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Ñ–∞–π–ª—ã —Ñ–æ—Ä–º–∞—Ç–∞ .csv", icon="‚ö†Ô∏è")
    uploaded_file = upload_file()
    if uploaded_file is not None:
        _, file_extension = os.path.splitext(uploaded_file.name)
        if file_extension.lower() == ".csv":
            try:
                df = pd.read_csv(uploaded_file, index_col=0)
                if "original_data" not in st.session_state:
                    st.session_state["original_data"] = df
                else:
                    st.session_state["original_data"] = df
                if "uploaded" not in st.session_state:
                    st.session_state["uploaded"] = True
                st.dataframe(df)
            except Exception as e:
                st.error(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {e}", icon="üö®")
        else:
            st.error("–ó–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π —Ñ–∞–π–ª –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ñ–æ—Ä–º–∞—Ç—É CSV", icon="üö®")

    with st.expander(
        "–ß—Ç–æ —Ç–∞–∫–æ–µ `CSV` –∏ –ø–æ—á–µ–º—É —Å–∞–π—Ç –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Ñ–∞–π–ª—ã —ç—Ç–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞?"
    ):
        st.write(
            """
            **CSV (Comma-Separated Values)** ‚Äî —ç—Ç–æ —Ñ–æ—Ä–º–∞—Ç —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞, –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–π –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–∞–±–ª–∏—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö. 
            –ö–∞–∂–¥–∞—è —Å—Ç—Ä–æ–∫–∞ —Ñ–∞–π–ª–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É —Ç–∞–±–ª–∏—Ü—ã, –∞ —Å—Ç–æ–ª–±—Ü—ã —Ä–∞–∑–¥–µ–ª—è—é—Ç—Å—è –∑–∞–ø—è—Ç—ã–º–∏ –∏–ª–∏ –¥—Ä—É–≥–∏–º–∏ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏, —Ç–∞–∫–∏–º–∏ –∫–∞–∫ —Ç–æ—á–∫–∞ —Å –∑–∞–ø—è—Ç–æ–π. 
            –ü—Ä–∏–º–µ—Ä —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ CSV-—Ñ–∞–π–ª–∞:   
        """
        )
        small_code = """
        name,age,city
        John,34,New York
        Jane,28,Los Angeles
        """
        st.code(small_code, language="python")
        st.write(
            """
            –í —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ –¥–∞–Ω–Ω—ã–µ –æ –ª—é–¥—è—Ö —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ, –≥–¥–µ –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ ‚Äî —ç—Ç–æ –∑–∞–≥–æ–ª–æ–≤–∫–∏ —Å—Ç–æ–ª–±—Ü–æ–≤, –∞ –ø–æ—Å–ª–µ–¥—É—é—â–∏–µ —Å—Ç—Ä–æ–∫–∏ ‚Äî —ç—Ç–æ –∑–∞–ø–∏—Å–∏ –¥–∞–Ω–Ω—ã—Ö.
            
            **CSV —Ñ–∞–π–ª—ã —è–≤–ª—è—é—Ç—Å—è –æ–¥–Ω–∏–º –∏–∑ —Å–∞–º—ã—Ö –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω—ã–º–∏ –≤ –æ–±–ª–∞—Å—Ç–∏ `Data Science` –ø–æ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º –ø—Ä–∏—á–∏–Ω–∞–º:**
            
            **1.–ü—Ä–æ—Å—Ç–æ—Ç–∞ –∏ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ—Å—Ç—å:** –§–æ—Ä–º–∞—Ç CSV –ø—Ä–æ—Å—Ç –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è –∏ –º–æ–∂–µ—Ç –±—ã—Ç—å –ª–µ–≥–∫–æ –ø—Ä–æ—á–∏—Ç–∞–Ω –∫–∞–∫ –ª—é–¥—å–º–∏, —Ç–∞–∫ –∏ –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω—ã–º–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∞–º–∏. –ï–≥–æ –º–æ–∂–Ω–æ –æ—Ç–∫—Ä—ã—Ç—å –≤ –ª—é–±–æ–º —Ç–µ–∫—Å—Ç–æ–≤–æ–º —Ä–µ–¥–∞–∫—Ç–æ—Ä–µ, —Ç–∞–±–ª–∏—Ü–∞—Ö Excel –∏–ª–∏ Google Sheets, –∞ —Ç–∞–∫–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Å –ø–æ–º–æ—â—å—é –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –∞–Ω–∞–ª–∏–∑–∞ –¥–∞–Ω–Ω—ã—Ö.
            
            **2.–°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å:** CSV —Ñ–∞–π–ª—ã –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –≤—Å–µ–º–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏ –∞–Ω–∞–ª–∏–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏ –±–∞–∑–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –∏—Ö —É–¥–æ–±–Ω—ã–º –≤—ã–±–æ—Ä–æ–º –¥–ª—è –æ–±–º–µ–Ω–∞ –¥–∞–Ω–Ω—ã–º–∏ –º–µ–∂–¥—É —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏ –∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è–º–∏.
            
            **3.–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:** –•–æ—Ç—è CSV –Ω–µ —Å–∞–º—ã–π —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–∏—Å–∫–æ–≤–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ (–ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é, –Ω–∞–ø—Ä–∏–º–µ—Ä, —Å –±–∏–Ω–∞—Ä–Ω—ã–º–∏ —Ñ–æ—Ä–º–∞—Ç–∞–º–∏), –µ–≥–æ –ø—Ä–æ—Å—Ç–æ—Ç–∞ –∫–æ–º–ø–µ–Ω—Å–∏—Ä—É–µ—Ç —ç—Ç–æ –∑–∞ —Å—á–µ—Ç –ª–µ–≥–∫–æ—Å—Ç–∏ —á—Ç–µ–Ω–∏—è –∏ –Ω–∞–ø–∏—Å–∞–Ω–∏—è –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–∞—Ä—Å–µ—Ä–æ–≤ –∏–ª–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫.
            
            **4.–ì–∏–±–∫–æ—Å—Ç—å:** CSV —Ñ–∞–π–ª—ã –ª–µ–≥–∫–æ –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å, –ø–æ–∑–≤–æ–ª—è—è –¥–æ–±–∞–≤–ª—è—Ç—å, —É–¥–∞–ª—è—Ç—å –∏–ª–∏ –∏–∑–º–µ–Ω—è—Ç—å —Å—Ç—Ä–æ–∫–∏ –∏ —Å—Ç–æ–ª–±—Ü—ã –±–µ–∑ —Å–ª–æ–∂–Ω–æ—Å—Ç–µ–π. –≠—Ç–æ –¥–µ–ª–∞–µ—Ç –∏—Ö –∏–¥–µ–∞–ª—å–Ω—ã–º–∏ –¥–ª—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —ç—Ç–∞–ø–æ–≤ —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω—ã–º–∏, –æ—Ç –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–π –æ—á–∏—Å—Ç–∫–∏ –∏ –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–æ –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏.
            
            –ò–∑-–∑–∞ —ç—Ç–∏—Ö –ø—Ä–∏—á–∏–Ω CSV —Ñ–∞–π–ª—ã –æ—Å—Ç–∞—é—Ç—Å—è –æ–¥–Ω–∏–º –∏–∑ —Å–∞–º—ã—Ö —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω—ã–º–∏ –≤ –æ–±–ª–∞—Å—Ç–∏ Data Science, –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤, —Ç–∞–∫–∏—Ö –∫–∞–∫ `JSON`, `XML` –∏ –±–∏–Ω–∞—Ä–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, `Parquet` –∏ `HDF5`), –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –±–æ–ª–µ–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–º–∏ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è. 
        """
        )

    st.write(
        """
            –û—Ç–ª–∏—á–Ω–æ, —Ç–µ–ø–µ—Ä—å –ø–æ—Ä–∞–±–æ—Ç–∞–µ–º —Å –¥–∞–Ω–Ω—ã–º–∏ –∏ –ø—Ä–∏–≤–µ–¥—ë–º –∏—Ö –≤ –ø–æ—Ä—è–¥–æ–∫. :sunglasses:
        """
    )


def page_third():
    if "uploaded" not in st.session_state:
        st.info("–°–Ω–∞—á–∞–ª–∞ –≤—ã –¥–æ–ª–∂–Ω—ã –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ")
    else:
        if "data" not in st.session_state:
            st.session_state["data"] = st.session_state["original_data"].copy()

        df = st.session_state["original_data"].copy()

        st.title("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö")

        st.subheader("–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –¥–∞—Ç–∞—Ñ—Ä–µ–π–º")
        with st.expander("–ß—Ç–æ —Ç–∞–∫–æ–µ `–¥–∞—Ç–∞—Ñ—Ä–µ–π–º`?"):
            st.write(
                """DataFrame ‚Äî —ç—Ç–æ —Ç–µ—Ä–º–∏–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –∏ –∞–Ω–∞–ª–∏–∑–µ –¥–∞–Ω–Ω—ã—Ö, –æ—Å–æ–±–µ–Ω–Ω–æ –≤ —Ç–∞–∫–∏—Ö —è–∑—ã–∫–∞—Ö –∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞—Ö, –∫–∞–∫ Python (Pandas), R, –∏ –¥—Ä—É–≥–∏—Ö. –≠—Ç–æ –¥–≤—É–º–µ—Ä–Ω–∞—è, –∏–∑–º–µ–Ω—è–µ–º–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞, —Å—Ç—Ä–æ–∫–∏, –ø–ª–∞–≤–∞—é—â–∏–µ —Ç–æ—á–∫–∏), –∏ —ç—Ç–æ –¥–µ–ª–∞–µ—Ç –µ—ë –æ—á–µ–Ω—å —É–¥–æ–±–Ω–æ–π –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ç–∞–±–ª–∏—á–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏. DataFrame –æ–±—ã—á–Ω–æ –≤–∫–ª—é—á–∞–µ—Ç –≤ —Å–µ–±—è —Å—Ç—Ä–æ–∫–∏ –∏ —Å—Ç–æ–ª–±—Ü—ã, –≥–¥–µ —Å—Ç—Ä–æ–∫–∏ –æ–±–æ–∑–Ω–∞—á–∞—é—Ç –Ω–∞–±–ª—é–¥–µ–Ω–∏—è, –∞ —Å—Ç–æ–ª–±—Ü—ã ‚Äî –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ.

–û—Å–Ω–æ–≤–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ DataFrame –≤–∫–ª—é—á–∞—é—Ç –≤ —Å–µ–±—è:
- –ß—Ç–µ–Ω–∏–µ –∏ –∑–∞–ø–∏—Å—å –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤, —Ç–∞–∫–∏—Ö –∫–∞–∫ CSV, Excel —Ñ–∞–π–ª—ã, –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∏ –¥—Ä—É–≥–∏–µ.
- –ú–∞–Ω–∏–ø—É–ª—è—Ü–∏–∏ —Å –¥–∞–Ω–Ω—ã–º–∏: —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è, —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞, –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞, –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ (join) –∏ –¥—Ä—É–≥–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏.
- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏, –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏—Ö –∑–∞–º–µ—â–µ–Ω–∏—è –∏–ª–∏ —É–¥–∞–ª–µ–Ω–∏—è.
- –ê–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö, –ø–æ–∑–≤–æ–ª—è—é—â–µ–µ –≤—ã–ø–æ–ª–Ω—è—Ç—å —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ —Ä–∞—Å—á–µ—Ç—ã.
- –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö —Å –ø–æ–º–æ—â—å—é –≥—Ä–∞—Ñ–∏–∫–æ–≤ –∏ –¥–∏–∞–≥—Ä–∞–º–º."""
            )
        st.dataframe(df, hide_index=True)
        st.write(
            "–†–∞–∑–º–µ—Ä –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞ =", df.shape[0], "–¥–∞–Ω–Ω—ã—Ö –∏ ", df.shape[1], "–ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤"
        )
        with st.container():
            st.warning(
                "–ü–µ—Ä–µ–¥ –∑–∞–≥—Ä—É–∑–∫–æ–π –¥—Ä—É–≥–æ–≥–æ –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –Ω—É–∂–Ω–æ –Ω–∞–∂–∞—Ç—å –Ω–∞ –∫–Ω–æ–ø–∫—É!"
            )
            if st.button("–ò–∑–º–µ–Ω–µ–Ω–∏–µ –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞", use_container_width=True):
                reset_application_state_with_data()
        st.subheader("1. –û–±—â–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è")
        col1, col2 = st.columns(2)
        show_describe, show_unique = False, False
        with col1:
            if st.button("describe( )", use_container_width=True):
                show_describe = True
        if show_describe == True:
            st.dataframe(df.describe())
        with col2:
            if st.button("nunique( )", use_container_width=True):
                show_unique = True
        if show_unique == True:
            st.dataframe(pd.DataFrame(df.nunique(), columns=["num of unique values"]))

        with st.expander("—á—Ç–æ –¥–µ–ª–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—è `describe()`?"):
            st.write(
                """
        –§—É–Ω–∫—Ü–∏—è `describe()` –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ pandas –≤ Python –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ–ø–∏—Å–∞—Ç–µ–ª—å–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –¥–∞–Ω–Ω—ã–º –≤ `DataFrame` –∏–ª–∏ `Series`. –û–Ω–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É, –∫–æ—Ç–æ—Ä–∞—è –≤–∫–ª—é—á–∞–µ—Ç –≤ —Å–µ–±—è:

        - **count**: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ–Ω—É–ª–µ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
        - **mean**: —Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —á–∏—Å–ª–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        - **std**: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –∏–∑–º–µ—Ä—è–µ—Ç —Ä–∞–∑–±—Ä–æ—Å —á–∏—Å–ª–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö    
        - **min**: –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ      
        - **25%**: –ø–µ—Ä–≤—ã–π –∫–≤–∞—Ä—Ç–∏–ª—å (–º–µ–¥–∏–∞–Ω–∞ –ø–µ—Ä–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω—ã –¥–∞–Ω–Ω—ã—Ö)      
        - **50%**: –º–µ–¥–∏–∞–Ω–∞ –∏–ª–∏ –≤—Ç–æ—Ä–æ–π –∫–≤–∞—Ä—Ç–∏–ª—å (–º–µ–¥–∏–∞–Ω–∞ –≤—Å–µ–≥–æ –Ω–∞–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö)
        - **75%**: —Ç—Ä–µ—Ç–∏–π –∫–≤–∞—Ä—Ç–∏–ª—å (–º–µ–¥–∏–∞–Ω–∞ –≤—Ç–æ—Ä–æ–π –ø–æ–ª–æ–≤–∏–Ω—ã –¥–∞–Ω–Ω—ã—Ö)
        - **max**: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                
        –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é `describe()` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–ø–∏—Å–∞—Ç–µ–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç–æ–ª—å–∫–æ –¥–ª—è –∫–æ–ª–æ–Ω–æ–∫ —Å —á–∏—Å–ª–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏. 
        –û–¥–Ω–∞–∫–æ, –µ—ë –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏ –¥–ª—è –∫–æ–ª–æ–Ω–æ–∫ —Å –Ω–µ—á–∏—Å–ª–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ç–∏–ø `object` –∏–ª–∏ `categorical`), –ø–µ—Ä–µ–¥–∞–≤ –ø–∞—Ä–∞–º–µ—Ç—Ä include. 
        –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ —Ñ—É–Ω–∫—Ü–∏—è –º–æ–∂–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å —Ç–∞–∫—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É, –∫–∞–∫ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π, —Å–∞–º–æ–µ —á–∞—Å—Ç–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏ –µ–≥–æ —á–∞—Å—Ç–æ—Ç—É.

        –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ `describe()`:
        """
            )

            small_code = """
            # –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ—Å—Ç–æ–≥–æ DataFrame
            df = pd.DataFrame({
            '—á–∏—Å–ª–æ–≤–∞—è_–∫–æ–ª–æ–Ω–∫–∞': [1, 2, 3, 4, 5],
            '–∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω–∞—è_–∫–æ–ª–æ–Ω–∫–∞': ['A', 'B', 'A', 'B', 'C']
        })

        # –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ describe –∫ DataFrame
        –æ–ø–∏—Å–∞–Ω–∏–µ = df.describe()

        # –î–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è –æ–ø–∏—Å–∞—Ç–µ–ª—å–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –Ω–µ—á–∏—Å–ª–æ–≤—ã–º –∫–æ–ª–æ–Ω–∫–∞–º
        –æ–ø–∏—Å–∞–Ω–∏–µ_–≤—Å–µ = df.describe(include='all')
            """
            st.code(small_code, language="python")
            st.write(
                """
        –í –¥–∞–Ω–Ω–æ–º –ø—Ä–∏–º–µ—Ä–µ –æ–ø–∏—Å–∞–Ω–∏–µ –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç–æ–ª—å–∫–æ –¥–ª—è `—á–∏—Å–ª–æ–≤–∞—è_–∫–æ–ª–æ–Ω–∫–∞`, –≤ —Ç–æ –≤—Ä–µ–º—è –∫–∞–∫ –æ–ø–∏—Å–∞–Ω–∏–µ_–≤—Å–µ –≤–∫–ª—é—á–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –≤—Å–µ–º –∫–æ–ª–æ–Ω–∫–∞–º, –≤–∫–ª—é—á–∞—è `–∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω–∞—è_–∫–æ–ª–æ–Ω–∫–∞`.        
        """
            )
        with st.expander("–ß—Ç–æ –¥–µ–ª–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—è `nunique()`?"):
            st.write(
                """
        –§—É–Ω–∫—Ü–∏—è `nunique()` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ pandas –≤ Python –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –≤ —Å—Ç–æ–ª–±—Ü–µ `DataFrame` –∏–ª–∏ `Series`. 

        –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –æ—á–µ–Ω—å –ø–æ–ª–µ–∑–Ω–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ –¥–∞–Ω–Ω—ã—Ö, –ø–æ—Å–∫–æ–ª—å–∫—É –ø–æ–∑–≤–æ–ª—è–µ—Ç –±—ã—Å—Ç—Ä–æ –ø–æ–Ω—è—Ç—å, —Å–∫–æ–ª—å–∫–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º –Ω–∞–±–æ—Ä–µ –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –µ–≥–æ —á–∞—Å—Ç–∏.

        **–ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è**

        –î–æ–ø—É—Å—Ç–∏–º, —É –≤–∞—Å –µ—Å—Ç—å DataFrame df, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–∞–Ω–Ω—ã–µ –æ –∫–ª–∏–µ–Ω—Ç–∞—Ö, –≤–∫–ª—é—á–∞—è –∏—Ö –∏–º–µ–Ω–∞ –∏ –≥–æ—Ä–æ–¥–∞, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –æ–Ω–∏ –ø—Ä–æ–∂–∏–≤–∞—é—Ç. 
        –í—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `nunique()` –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∏–º–µ–Ω –∏ –≥–æ—Ä–æ–¥–æ–≤:
                    """
            )
            small_code = """
            import pandas as pd

            # –°–æ–∑–¥–∞–Ω–∏–µ DataFrame
            data = {
            'name': ['John', 'Jane', 'Mary', 'John', 'Mary'],
            'city': ['New York', 'Los Angeles', 'Los Angeles', 'New York', 'San Francisco']
        }
            df = pd.DataFrame(data)
            
            # –ü–æ–¥—Å—á–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∏–º–µ–Ω
            unique_names = df['name'].nunique()
            print(f"–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∏–º–µ–Ω: {unique_names}")
            
            # –ü–æ–¥—Å—á–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≥–æ—Ä–æ–¥–æ–≤, –≤–∫–ª—é—á–∞—è –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
            unique_cities = df['city'].nunique(dropna=False)
            print(f"–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≥–æ—Ä–æ–¥–æ–≤: {unique_cities}")    
        })"""
            st.code(small_code, language="python")
            st.write(
                """
        –í —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ df['name'].nunique() –≤–µ—Ä–Ω–µ—Ç `3`, —Ç–∞–∫ –∫–∞–∫ –≤ —Å—Ç–æ–ª–±—Ü–µ `name` —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è —Ç—Ä–∏ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∏–º–µ–Ω–∏ (John, Jane, Mary). 

        –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ, df['city'].nunique() –≤–µ—Ä–Ω–µ—Ç `3`, –ø–æ—Å–∫–æ–ª—å–∫—É –∏–º–µ–µ—Ç—Å—è —Ç—Ä–∏ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≥–æ—Ä–æ–¥–∞.

        –§—É–Ω–∫—Ü–∏—è `nunique()` —è–≤–ª—è–µ—Ç—Å—è –º–æ—â–Ω—ã–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–º –¥–ª—è –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –∏ –∞–Ω–∞–ª–∏–∑–∞ –¥–∞–Ω–Ω—ã—Ö, –ø–æ–∑–≤–æ–ª—è—è –±—ã—Å—Ç—Ä–æ –æ—Ü–µ–Ω–∏—Ç—å —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –≤ –Ω–∞–±–æ—Ä–∞—Ö –¥–∞–Ω–Ω—ã—Ö.
                    """
            )
        change_df = df
        st.subheader("2.–†–∞–±–æ—Ç–∞ —Å null –∑–Ω–∞—á–µ–Ω–∏—è–º–∏")
        with st.expander("–ß—Ç–æ —Ç–∞–∫–æ–µ `null` –∑–Ω–∞—á–µ–Ω–∏–µ?"):
            st.write(
                """Null –∑–Ω–∞—á–µ–Ω–∏–µ ‚Äî —ç—Ç–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –º–∞—Ä–∫–µ—Ä –≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –∏ –±–∞–∑–∞—Ö –¥–∞–Ω–Ω—ã—Ö, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –¥–ª—è –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏—è –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –∫–∞–∫–æ–≥–æ-–ª–∏–±–æ –∑–Ω–∞—á–µ–Ω–∏—è –∏–ª–∏ –¥–∞–Ω–Ω—ã—Ö. –í —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —Å–∏—Å—Ç–µ–º–∞—Ö —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–∞–∑–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö —ç—Ç–æ –º–æ–∂–µ—Ç –æ–±–æ–∑–Ω–∞—á–∞—Ç—å—Å—è –ø–æ-—Ä–∞–∑–Ω–æ–º—É, –Ω–∞–ø—Ä–∏–º–µ—Ä, `null` –≤ Java, `None` –≤ Python, `NULL` –≤ SQL.

–û—Å–Ω–æ–≤–Ω—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ null –∑–Ω–∞—á–µ–Ω–∏–π:
- –û–Ω–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è —É–∫–∞–∑–∞–Ω–∏—è –Ω–∞ —Ç–æ, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–µ –∏–º–µ–µ—Ç –ø—Ä–∏—Å–≤–æ–µ–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è.
- –í –±–∞–∑–∞—Ö –¥–∞–Ω–Ω—ã—Ö null –º–æ–∂–µ—Ç –æ–±–æ–∑–Ω–∞—á–∞—Ç—å –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤ –ø–æ–ª–µ.
- –ü—Ä–∏ –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏—è—Ö –∏–ª–∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è—Ö —Å —É—á–∞—Å—Ç–∏–µ–º null —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ–æ—á–µ–≤–∏–¥–Ω—ã–º–∏, —Ç–∞–∫ –∫–∞–∫ null –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –Ω–∏ –∏—Å—Ç–∏–Ω–æ–π, –Ω–∏ –ª–æ–∂—å—é, –Ω–∏ –Ω—É–ª–µ–º, –Ω–∏ –ª—é–±—ã–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤ SQL –≤—ã—Ä–∞–∂–µ–Ω–∏–µ `SELECT * FROM table WHERE column = NULL;` –Ω–µ –≤–µ—Ä–Ω–µ—Ç —Å—Ç—Ä–æ–∫–∏, –≥–¥–µ column —Å–æ–¥–µ—Ä–∂–∏—Ç null, –ø–æ—Å–∫–æ–ª—å–∫—É null –Ω–µ —Ä–∞–≤–µ–Ω –Ω–∏—á–µ–º—É, –¥–∞–∂–µ —Å–∞–º–æ–º—É —Å–µ–±–µ. –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è `IS NULL`.

–û–±—Ä–∞–±–æ—Ç–∫–∞ null –∑–Ω–∞—á–µ–Ω–∏–π —Ç—Ä–µ–±—É–µ—Ç –æ—Å–æ–±–æ–≥–æ –≤–Ω–∏–º–∞–Ω–∏—è –ø—Ä–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –∏ —Ä–∞–±–æ—Ç–µ —Å –¥–∞–Ω–Ω—ã–º–∏, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–æ–∫ –≤ –ª–æ–≥–∏–∫–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã –∏–ª–∏ –∞–Ω–∞–ª–∏–∑–µ –¥–∞–Ω–Ω—ã—Ö."""
            )
        st.write(
            "–¢—ã –º–æ–∂–µ—à—å —É–¥–∞–ª–∏—Ç—å —Å—Ç–æ–ª–±–µ—Ü —Å null –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –∏–ª–∏ –º–æ–∂–µ—à—å –∑–∞–ø–æ–ª–Ω–∏—Ç—å –µ–≥–æ –¥—Ä—É–≥–∏–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏. –í—ã–±–æ—Ä –∑–∞ —Ç–æ–±–æ–π."
        )
        with st.expander("–ö–∞–∫ –≤—ã–±—Ä–∞—Ç—å, –∫–∞–∫–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É–¥–∞–ª–∏—Ç—å, –∞ –∫–∞–∫–∏–µ –æ—Å—Ç–∞–≤–∏—Ç—å?"):
            st.write(
                """–í–æ –≤—Ä–µ–º—è –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö (–ø—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–∏–Ω–≥–∞) –∏–∑ DataFrame –æ–±—ã—á–Ω–æ —É–¥–∞–ª—è—é—Ç—Å—è –∏–ª–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä—É—é—Ç—Å—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (—Å—Ç–æ–ª–±—Ü—ã) –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏—Ö –≤–∞–∂–Ω–æ—Å—Ç–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∏–ª–∏ –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –∫–∞—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö. –í—ã–±–æ—Ä —Å—Ç–æ–ª–±—Ü–æ–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∏–ª–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –º–Ω–æ–≥–∏—Ö —Ñ–∞–∫—Ç–æ—Ä–æ–≤, –≤–∫–ª—é—á–∞—è —Ü–µ–ª–∏ –∞–Ω–∞–ª–∏–∑–∞, –∫–∞—á–µ—Å—Ç–≤–æ –∏ —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö. –ù–∏–∂–µ –ø—Ä–∏–≤–µ–¥–µ–Ω—ã –æ–±—â–∏–µ –∫—Ä–∏—Ç–µ—Ä–∏–∏ –¥–ª—è —Ä–µ—à–µ–Ω–∏—è, –∫–∞–∫–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —É–¥–∞–ª–∏—Ç—å –∏ –∫–∞–∫–∏–µ –æ—Å—Ç–∞–≤–∏—Ç—å:

### –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è

1. **–ù–µ—Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã**: –°—Ç–æ–ª–±—Ü—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –∏–º–µ—é—Ç –∑–Ω–∞—á–∏–º–æ—Å—Ç–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∏–ª–∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –º–æ–¥–µ–ª–∏. –ù–∞–ø—Ä–∏–º–µ—Ä, –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã, –∏–º–µ–Ω–∞, –º–µ—Ç–∫–∏ –≤—Ä–µ–º–µ–Ω–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ—Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–º–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∑–∞–¥–∞—á–∏.
2. **–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å –≤—ã—Å–æ–∫–∏–º –ø—Ä–æ—Ü–µ–Ω—Ç–æ–º –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π**: –ï—Å–ª–∏ –≤ —Å—Ç–æ–ª–±—Ü–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö, –∏ —ç—Ç–æ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∞–¥–µ–∫–≤–∞—Ç–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –∏–ª–∏ –∑–∞–º–µ–Ω–µ–Ω–æ, —Ç–∞–∫–æ–π —Å—Ç–æ–ª–±–µ—Ü —á–∞—Å—Ç–æ —É–¥–∞–ª—è—é—Ç.
3. **–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å –æ–¥–Ω–∏–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º (–∏–ª–∏ –æ—á–µ–Ω—å –Ω–∏–∑–∫–∏–º —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ–º)**: –°—Ç–æ–ª–±—Ü—ã, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ–¥–µ—Ä–∂–∞—Ç —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–ª–∏ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –∑–Ω–∞—á–µ–Ω–∏–π –æ–¥–∏–Ω–∞–∫–æ–≤—ã, –Ω–µ –Ω–µ—Å—É—Ç –ø–æ–ª–µ–∑–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.
4. **–°–∏–ª—å–Ω–æ –∫–æ—Ä—Ä–µ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã**: –ü–∞—Ä—ã –∏–ª–∏ –≥—Ä—É–ø–ø—ã –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —Å–∏–ª—å–Ω–æ –∫–æ—Ä—Ä–µ–ª–∏—Ä–æ–≤–∞–Ω—ã –¥—Ä—É–≥ —Å –¥—Ä—É–≥–æ–º, –º–æ–≥—É—Ç –±—ã—Ç—å –∏–∑–±—ã—Ç–æ—á–Ω—ã–º–∏. –û–±—ã—á–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç –æ–¥–∏–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä –∏–∑ –≥—Ä—É–ø–ø—ã –∫–æ—Ä—Ä–µ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –º—É–ª—å—Ç–∏–∫–æ–ª–ª–∏–Ω–µ–∞—Ä–Ω–æ—Å—Ç–∏.

### –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è

1. **–¶–µ–ª–µ–≤–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è**: –í –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –æ–±—É—á–µ–Ω–∏—è —Å —É—á–∏—Ç–µ–ª–µ–º, —Ü–µ–ª–µ–≤–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è (–∏–ª–∏ –∑–∞–≤–∏—Å–∏–º–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è), –∫–æ—Ç–æ—Ä—É—é –º–æ–¥–µ–ª—å –¥–æ–ª–∂–Ω–∞ –ø—Ä–µ–¥—Å–∫–∞–∑–∞—Ç—å, –≤—Å–µ–≥–¥–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è.
2. **–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å –≤—ã—Å–æ–∫–æ–π –ø—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–æ–π —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å—é**: –ü–∞—Ä–∞–º–µ—Ç—Ä—ã, –∫–æ—Ç–æ—Ä—ã–µ —Å—á–∏—Ç–∞—é—Ç—Å—è –≤–∞–∂–Ω—ã–º–∏ –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è —Ü–µ–ª–µ–≤–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∏–ª–∏ –∏–º–µ—é—Ç —Å–∏–ª—å–Ω—É—é —Å–≤—è–∑—å —Å –∏—Å—Å–ª–µ–¥—É–µ–º—ã–º —è–≤–ª–µ–Ω–∏–µ–º.
3. **–ü–∞—Ä–∞–º–µ—Ç—Ä—ã, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –∏–ª–∏ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –ø—Ä–∏–∑–Ω–∞–∫–æ–≤**: –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–≥—É—Ç –ø–æ–Ω–∞–¥–æ–±–∏—Ç—å—Å—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ (—Ñ–∏—á–∏ –∏–Ω–∂–∏–Ω–∏—Ä–∏–Ω–≥) –∏–ª–∏ –¥–ª—è –ø—Ä–æ–≤–µ–¥–µ–Ω–∏—è —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞.

–í–∞–∂–Ω–æ –æ—Ç–º–µ—Ç–∏—Ç—å, —á—Ç–æ —Ä–µ—à–µ–Ω–∏–µ –æ —Ç–æ–º, –∫–∞–∫–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —É–¥–∞–ª—è—Ç—å –∏–ª–∏ –æ—Å—Ç–∞–≤–ª—è—Ç—å, –¥–æ–ª–∂–Ω–æ –æ—Å–Ω–æ–≤—ã–≤–∞—Ç—å—Å—è –Ω–∞ —Ç—â–∞—Ç–µ–ª—å–Ω–æ–º –∞–Ω–∞–ª–∏–∑–µ –¥–∞–Ω–Ω—ã—Ö –∏ –∑–Ω–∞–Ω–∏–∏ –ø—Ä–µ–¥–º–µ—Ç–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏. –ò–Ω–æ–≥–¥–∞ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è —Å—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ –º–µ—Ç–æ–¥—ã –∏ –º–µ—Ç–æ–¥—ã –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è –¥–ª—è –æ—Ü–µ–Ω–∫–∏ –≤–∞–∂–Ω–æ—Å—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –ø–µ—Ä–µ–¥ –∏—Ö —É–¥–∞–ª–µ–Ω–∏–µ–º –∏–ª–∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ–º."""
            )

        delete_column = create_toggle("delete_column_toggle", "–£–¥–∞–ª–∏—Ç—å")
        if delete_column:
            options = st.multiselect(
                "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–∫–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å:",
                change_df.columns,
                key=persist("delete_columns_multiselect"),
            )
            change_df = delete_columns(change_df, options)
        st.write(
            "–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã–µ –∏ —á–∏—Å–ª–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ —Å–≤–æ–µ–≥–æ –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞."
        )

        with st.expander(
            "–í —á–µ–º —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã–º–∏ –∏ —á–∏—Å–ª–æ–≤—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏?"
        ):
            st.write(
                """–ö–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã–µ –∏ —á–∏—Å–ª–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã ‚Äî —ç—Ç–æ –¥–≤–∞ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Ç–∏–ø–∞ –¥–∞–Ω–Ω—ã—Ö, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –≤—ã –≤—Å—Ç—Ä–µ—Ç–∏—Ç–µ—Å—å –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –¥–∞—Ç–∞—Å–µ—Ç–∞–º–∏ –≤ –∞–Ω–∞–ª–∏–∑–µ –¥–∞–Ω–Ω—ã—Ö –∏ –º–∞—à–∏–Ω–Ω–æ–º –æ–±—É—á–µ–Ω–∏–∏. –ö–∞–∂–¥—ã–π –∏–∑ –Ω–∏—Ö –∏–≥—Ä–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—É—é —Ä–æ–ª—å –≤ –∞–Ω–∞–ª–∏–∑–µ –∏ —Ç—Ä–µ–±—É–µ—Ç —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤ –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∏. –í–æ—Ç –ø–æ–¥—Ä–æ–±–Ω–æ–µ –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ:

### –ö–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
–ö–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —Å–æ–±–æ–π —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä—ã–π –æ–ø–∏—Å—ã–≤–∞–µ—Ç –≥—Ä—É–ø–ø—ã –∏–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏. –û–Ω–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –∫–∞–∫ —á–∏—Å–ª–µ–Ω–Ω—ã–º–∏, —Ç–∞–∫ –∏ —Ç–µ–∫—Å—Ç–æ–≤—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏, –Ω–æ —ç—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ –∏–º–µ—é—Ç –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–º—ã—Å–ª–∞. –ö–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–¥—Ä–∞–∑–¥–µ–ª—è—é—Ç—Å—è –Ω–∞ –¥–≤–∞ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Ç–∏–ø–∞:

- **–ù–æ–º–∏–Ω–∞–ª—å–Ω—ã–µ**: –î–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –æ–ø–∏—Å—ã–≤–∞—é—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –±–µ–∑ –∫–∞–∫–æ–≥–æ-–ª–∏–±–æ –ø–æ—Ä—è–¥–∫–∞ –∏–ª–∏ —Ä–∞–Ω–∂–∏—Ä–æ–≤–∞–Ω–∏—è. –ü—Ä–∏–º–µ—Ä—ã –≤–∫–ª—é—á–∞—é—Ç —Ü–≤–µ—Ç–∞, —Ç–∏–ø—ã –∂–∏–ª—å—è, –Ω–∞–∑–≤–∞–Ω–∏—è –º–∞—Ä–æ–∫ –∞–≤—Ç–æ–º–æ–±–∏–ª–µ–π.
- **–ü–æ—Ä—è–¥–∫–æ–≤—ã–µ**: –î–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –≤–∫–ª—é—á–∞—é—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —Å –Ω–µ–∫–æ—Ç–æ—Ä—ã–º –ø–æ—Ä—è–¥–∫–æ–º –∏–ª–∏ –∏–µ—Ä–∞—Ä—Ö–∏–µ–π. –ü—Ä–∏–º–µ—Ä—ã –≤–∫–ª—é—á–∞—é—Ç —Ä–µ–π—Ç–∏–Ω–≥–∏ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è (—Ö–æ—Ä–æ—à–æ, —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ, –ø–ª–æ—Ö–æ), —É—Ä–æ–≤–µ–Ω—å –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è (–≤—ã—Å—à–µ–µ, —Å—Ä–µ–¥–Ω–µ–µ, –Ω–∏–∑—à–µ–µ).

### –ß–∏—Å–ª–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
–ß–∏—Å–ª–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —Å–æ–±–æ–π –¥–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –∏–∑–º–µ—Ä—è—é—Ç—Å—è —á–∏—Å–ª–µ–Ω–Ω–æ. –≠—Ç–∏ –¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π. –ß–∏—Å–ª–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ —Ç–∞–∫–∂–µ –¥–µ–ª—è—Ç—Å—è –Ω–∞ –¥–≤–∞ —Ç–∏–ø–∞:

- **–î–∏—Å–∫—Ä–µ—Ç–Ω—ã–µ**: –î–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏–Ω–∏–º–∞—é—Ç —Ç–æ–ª—å–∫–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è. –≠—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏—è –æ–±—ã—á–Ω–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —Å–æ–±–æ–π —Å—á–µ—Ç–Ω—ã–µ –≤–µ–ª–∏—á–∏–Ω—ã. –ü—Ä–∏–º–µ—Ä—ã –≤–∫–ª—é—á–∞—é—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–≤—Ç–æ–º–æ–±–∏–ª–µ–π –≤ –¥–æ–º–æ—Ö–æ–∑—è–π—Å—Ç–≤–µ, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ—Ç–µ–π –≤ —Å–µ–º—å–µ.
- **–ù–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–µ**: –î–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å –ª—é–±–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –¥–∏–∞–ø–∞–∑–æ–Ω–∞. –ü—Ä–∏–º–µ—Ä—ã –≤–∫–ª—é—á–∞—é—Ç –≤–µ—Å, —Ä–æ—Å—Ç, —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—É.

### –ü—Å–µ–≤–¥–æ-—á–∏—Å–ª–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
–ü—Å–µ–≤–¥–æ-—á–∏—Å–ª–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã ‚Äî —ç—Ç–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –∫–æ–¥–∏—Ä—É—é—Ç—Å—è —á–∏—Å–ª–∞–º–∏, –Ω–æ —ç—Ç–∏ —á–∏—Å–ª–∞ –Ω–µ –∏–º–µ—é—Ç —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –∏–ª–∏ –ø–æ—Ä—è–¥–∫–∞. –ü—Ä–∏–º–µ—Ä–æ–º –º–æ–∂–µ—Ç —Å–ª—É–∂–∏—Ç—å –ø–æ—á—Ç–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å. –•–æ—Ç—è –ø–æ—á—Ç–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å –∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω —á–∏—Å–ª–∞–º–∏, –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ (—Å–ª–æ–∂–µ–Ω–∏–µ, —É–º–Ω–æ–∂–µ–Ω–∏–µ –∏ —Ç.–¥.) –Ω–∞–¥ —ç—Ç–∏–º–∏ —á–∏—Å–ª–∞–º–∏ –Ω–µ –∏–º–µ—é—Ç —Å–º—ã—Å–ª–∞ —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è –∏—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è. –¢–∞–∫–∏–µ –¥–∞–Ω–Ω—ã–µ —á–∞—Å—Ç–æ —Ç—Ä–µ–±—É—é—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤ –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏—Ö –º–æ–¥–µ–ª—è—Ö, –Ω–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤ one-hot encoding –∏–ª–∏ –¥—Ä—É–≥–∏–µ —Ñ–æ—Ä–º—ã –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω–æ–≥–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è, —á—Ç–æ–±—ã –º–æ–¥–µ–ª—å –º–æ–≥–ª–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é."""
            )

        options_categorical = st.multiselect(
            "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã",
            change_df.columns,
            key=persist("select_categorical_columns_multiselect"),
        )
        categorical_data = df[options_categorical]

        options_numerical = st.multiselect(
            "–í—ã–±–µ—Ä–∏—Ç–µ —á–∏—Å–ª–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã",
            change_df.columns,
            key=persist("select_numerical_columns_multiselect"),
        )
        numerical_data = df[options_numerical]

        fill_numerical = create_toggle(
            "fill_numerical_missing_toggle", "–ó–∞–ø–æ–ª–Ω–∏—Ç—å —á–∏—Å–ª–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã"
        )
        if fill_numerical:
            options = st.multiselect(
                "–í—ã–±–µ—Ä–∏—Ç–µ —á–∏—Å–ª–æ–≤—É—é –∫–æ–ª–æ–Ω–∫—É –∫–æ—Ç–æ—Ä—É—é —Ö–æ—Ç–∏—Ç–µ –∑–∞–ø–æ–ª–Ω–∏—Ç—å",
                numerical_data.columns,
                key=persist("select_to_fill_numerical_columns_multiselect"),
            )
            change_df = fill_numerical_data(change_df, options)

        fill_categorical = create_toggle(
            "fill_categorical_missing_toggle", "–ó–∞–ø–æ–ª–Ω–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã"
        )
        if fill_categorical:
            options = st.multiselect(
                "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—É—é –∫–æ–ª–æ–Ω–∫—É –∫–æ—Ç–æ—Ä—É—é —Ö–æ—Ç–∏—Ç–µ –∑–∞–ø–æ–ª–Ω–∏—Ç—å",
                categorical_data.columns,
                key=persist("select_to_fill_categorical_columns_multiselect"),
            )
            change_df = fill_categorical_data(change_df, options)

        with st.expander(
            "–ö–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ —á–∏—Å–ª–æ–≤—ã—Ö –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤?"
        ):
            st.write(
                """
### –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –≤ —á–∏—Å–ª–æ–≤—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–∞—Ö —Å –ø–æ–º–æ—â—å—é –º–µ–¥–∏–∞–Ω—ã

–ö–æ–≥–¥–∞ –º—ã —Å—Ç–∞–ª–∫–∏–≤–∞–µ–º—Å—è —Å –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –≤ —á–∏—Å–ª–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö, –æ–¥–Ω–∏–º –∏–∑ –Ω–∞–∏–±–æ–ª–µ–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤ –∏—Ö –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è —è–≤–ª—è–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–µ–¥–∏–∞–Ω—ã. –ú–µ–¥–∏–∞–Ω–∞ ‚Äî —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –¥–µ–ª–∏—Ç —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –¥–≤–µ —Ä–∞–≤–Ω—ã–µ —á–∞—Å—Ç–∏. –î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, —ç—Ç–æ —Å—Ä–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –≤ —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω–æ–º —Å–ø–∏—Å–∫–µ —á–∏—Å–µ–ª. –ï—Å–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —á–µ—Ç–Ω–æ–µ, –º–µ–¥–∏–∞–Ω–∞ –±—É–¥–µ—Ç —Å—Ä–µ–¥–Ω–∏–º –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–º –¥–≤—É—Ö —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª.

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–µ–¥–∏–∞–Ω—ã –≤ –∫–∞—á–µ—Å—Ç–≤–µ –º–µ—Ç–æ–¥–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–æ, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω–∞ –º–µ–Ω–µ–µ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –∫ –≤—ã–±—Ä–æ—Å–∞–º –≤ –¥–∞–Ω–Ω—ã—Ö –ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å–æ —Å—Ä–µ–¥–Ω–∏–º –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–º. –≠—Ç–æ –¥–µ–ª–∞–µ—Ç –º–µ–¥–∏–∞–Ω—É –Ω–∞–¥–µ–∂–Ω—ã–º –≤—ã–±–æ—Ä–æ–º –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π, –æ—Å–æ–±–µ–Ω–Ω–æ –≤ —Å–ª—É—á–∞—è—Ö, –∫–æ–≥–¥–∞ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–º–µ–µ—Ç —Ç—è–∂–µ–ª—ã–µ —Ö–≤–æ—Å—Ç—ã –∏–ª–∏ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–º.

### –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–∞—Ö —Å –ø–æ–º–æ—â—å—é –º–æ–¥—ã

–î–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö, –≥–¥–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —Å–æ–±–æ–π –≥—Ä—É–ø–ø—ã –∏–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏, –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —á–∞—Å—Ç–æ –∑–∞–ø–æ–ª–Ω—è—é—Ç—Å—è –º–æ–¥–æ–π. –ú–æ–¥–∞ ‚Äî —ç—Ç–æ –Ω–∞–∏–±–æ–ª–µ–µ —á–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞—é—â–µ–µ—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –Ω–∞–±–æ—Ä–µ –¥–∞–Ω–Ω—ã—Ö. –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –æ—Å–æ–±–µ–Ω–Ω–æ –ø–æ–ª–µ–∑–µ–Ω, –∫–æ–≥–¥–∞ –µ—Å—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —á–∞—â–µ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è, —á–µ–º –¥—Ä—É–≥–∏–µ, –∏, —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —Å–æ–±–æ–π "—Ç–∏–ø–∏—á–Ω—ã–µ" —Å–ª—É—á–∞–∏.

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–æ–¥—ã –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–∑–≤–æ–ª—è–µ—Ç —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –≤ –Ω–∞–±–æ—Ä–µ –¥–∞–Ω–Ω—ã—Ö –∏ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –ø—Ä–æ—Å—Ç–æ–π, –Ω–æ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π —Å–ø–æ—Å–æ–± –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π. –≠—Ç–æ –æ—Å–æ–±–µ–Ω–Ω–æ –∞–∫—Ç—É–∞–ª—å–Ω–æ –≤ —Å–ª—É—á–∞—è—Ö, –∫–æ–≥–¥–∞ –Ω–µ—Ç —è–≤–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ –∏–ª–∏ –∏–µ—Ä–∞—Ä—Ö–∏–∏ —Å—Ä–µ–¥–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–µ–¥–∏–∞–Ω—ã –∏–ª–∏ —Å—Ä–µ–¥–Ω–µ–≥–æ –Ω–µ–ø—Ä–∏–º–µ–Ω–∏–º—ã–º.

–û–±–∞ —ç—Ç–∏ –º–µ—Ç–æ–¥–∞ ‚Äî –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –º–µ–¥–∏–∞–Ω–æ–π –¥–ª—è —á–∏—Å–ª–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏ –º–æ–¥–æ–π –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö ‚Äî —è–≤–ª—è—é—Ç—Å—è –ø—Ä–∏–º–µ—Ä–∞–º–∏ "–æ–¥–Ω–æ–º–µ—Ä–Ω–æ–π –∏–º–ø—É—Ç–∞—Ü–∏–∏", –≥–¥–µ –∫–∞–∂–¥—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –∑–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –¥—Ä—É–≥–∏—Ö, –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ–≥–æ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π. –≠—Ç–∏ –ø–æ–¥—Ö–æ–¥—ã –ø–æ–∑–≤–æ–ª—è—é—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, –º–∏–Ω–∏–º–∏–∑–∏—Ä—É—è –∏—Å–∫–∞–∂–µ–Ω–∏–µ –≤ –¥–∞–Ω–Ω—ã—Ö –∏ —Å–æ—Ö—Ä–∞–Ω—è—è –∏—Ö —Å—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞."""
            )
        nulls_change = check_nulls(change_df)
        st.dataframe(nulls_change, width=500)
        st.dataframe(change_df, hide_index=True)

        st.subheader("3.–†–∞–±–æ—Ç–∞ —Å –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏")

        with st.expander(
            "–ö–∞–∫–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –≤—ã–ø–æ–ª–Ω—è—é—Ç `one hot encoding`, `label encoding`, `ordinal encoding`?"
        ):
            st.write(
                """One Hot Encoding, Label Encoding –∏ Ordinal Encoding ‚Äî —ç—Ç–æ —Ç–µ—Ö–Ω–∏–∫–∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –≤ —á–∏—Å–ª–æ–≤–æ–π —Ñ–æ—Ä–º–∞—Ç, —á—Ç–æ–±—ã –∏—Ö –º–æ–∂–Ω–æ –±—ã–ª–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –∞–ª–≥–æ—Ä–∏—Ç–º–∞—Ö –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è, –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –∏–∑ –∫–æ—Ç–æ—Ä—ã—Ö —Ç—Ä–µ–±—É—é—Ç —á–∏—Å–ª–æ–≤–æ–≥–æ –≤–≤–æ–¥–∞. –í–æ—Ç –æ–±–∑–æ—Ä –∫–∞–∂–¥–æ–π —Ç–µ—Ö–Ω–∏–∫–∏ –∏ –∏—Ö –ø–æ–ª—å–∑–∞:

### One Hot Encoding
One Hot Encoding –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∫–∞–∂–¥—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é –≤ –Ω–æ–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü –∏ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç 1 –∏–ª–∏ 0 –≤ –∫–∞–∂–¥–æ–º –∏–∑ –Ω–∏—Ö –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ–≥–æ, –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—è –≤ –∑–∞–ø–∏—Å–∏. –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ —É –Ω–∞—Å –µ—Å—Ç—å –ø—Ä–∏–∑–Ω–∞–∫ "—Ü–≤–µ—Ç" —Å —Ç—Ä–µ–º—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏ (–ö—Ä–∞—Å–Ω—ã–π, –ó–µ–ª–µ–Ω—ã–π, –°–∏–Ω–∏–π), One Hot Encoding —Å–æ–∑–¥–∞—Å—Ç —Ç—Ä–∏ –Ω–æ–≤—ã—Ö —Å—Ç–æ–ª–±—Ü–∞, –ø–æ –æ–¥–Ω–æ–º—É –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ü–≤–µ—Ç–∞, –∏ –ø–æ–º–µ—Å—Ç–∏—Ç 1 –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Å—Ç–æ–ª–±–µ—Ü, –µ—Å–ª–∏ —ç—Ç–æ—Ç —Ü–≤–µ—Ç –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –∏ 0 –≤ –¥—Ä—É–≥–∏–µ.

**–ü–æ–ª—å–∑–∞**: –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –∏–¥–µ–∞–ª—å–Ω–æ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –Ω–æ–º–∏–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö, –≥–¥–µ –Ω–µ—Ç —è–≤–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ –º–µ–∂–¥—É –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏, –ø–æ—Å–∫–æ–ª—å–∫—É –æ–Ω –Ω–µ –≤–Ω–æ—Å–∏—Ç –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –∏ –ø–æ–∑–≤–æ–ª—è–µ—Ç –º–æ–¥–µ–ª–∏ —Ç–æ—á–Ω–æ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä–æ–≤–∞—Ç—å –Ω–∞–ª–∏—á–∏–µ –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∫–∞–∂–¥–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.

### Label Encoding
Label Encoding –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç –∫–∞–∂–¥–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ —É –Ω–∞—Å –µ—Å—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (–ö—Ä–∞—Å–Ω—ã–π, –ó–µ–ª–µ–Ω—ã–π, –°–∏–Ω–∏–π), Label Encoding –º–æ–∂–µ—Ç –ø—Ä–∏—Å–≤–æ–∏—Ç—å –ö—Ä–∞—Å–Ω—ã–π = 1, –ó–µ–ª–µ–Ω—ã–π = 2, –°–∏–Ω–∏–π = 3. 

**–ü–æ–ª—å–∑–∞**: –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ —É–º–µ–Ω—å—à–∞–µ—Ç —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö, –ø—Ä–µ–æ–±—Ä–∞–∑—É—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –æ–¥–∏–Ω —Å—Ç–æ–ª–±–µ—Ü —á–∏—Å–µ–ª, —á—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–ª–µ–∑–Ω–æ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ –º–æ–¥–µ–ª–µ–π. –û–¥–Ω–∞–∫–æ –æ–Ω –≤–Ω–æ—Å–∏—Ç –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–º, –æ—Å–æ–±–µ–Ω–Ω–æ –¥–ª—è –Ω–æ–º–∏–Ω–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö.

### Ordinal Encoding
Ordinal Encoding –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —á–∏—Å–ª–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º —Å–æ–≥–ª–∞—Å–Ω–æ –∏—Ö –ø–æ—Ä—è–¥–∫—É –∏–ª–∏ —Ä–∞–Ω–≥—É. –≠—Ç–æ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –ø–æ—Ä—è–¥–∫–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö, –≥–¥–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏–º–µ—é—Ç —è–≤–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –∏–ª–∏ –∏–µ—Ä–∞—Ä—Ö–∏—é. –ù–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è —Ä–µ–π—Ç–∏–Ω–≥–∞ —É—Å–ª—É–≥ (–ø–ª–æ—Ö–æ, —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ, —Ö–æ—Ä–æ—à–æ) –º–æ–∂–Ω–æ –ø—Ä–∏—Å–≤–æ–∏—Ç—å –ø–ª–æ—Ö–æ = 1, —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ = 2, —Ö–æ—Ä–æ—à–æ = 3.

**–ü–æ–ª—å–∑–∞**: Ordinal Encoding —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ—Ä—è–¥–∫–µ –º–µ–∂–¥—É –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏, —á—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–ª–µ–∑–Ω–æ –¥–ª—è –º–æ–¥–µ–ª–µ–π, —á—Ç–æ–±—ã —É–ª–æ–≤–∏—Ç—å –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É –ø–æ—Ä—è–¥–∫–æ–≤—É—é —Å–≤—è–∑—å.

### –ó–∞—á–µ–º —ç—Ç–æ –Ω—É–∂–Ω–æ –¥–µ–ª–∞—Ç—å?
–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –≤ —á–∏—Å–ª–æ–≤—ã–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ, –ø–æ—Å–∫–æ–ª—å–∫—É –º–Ω–æ–≥–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è –º–æ–≥—É—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ —Ä–∞–±–æ—Ç–∞—Ç—å —Ç–æ–ª—å–∫–æ —Å —á–∏—Å–ª–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏. –≠—Ç–∏ –º–µ—Ç–æ–¥—ã –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –ø–æ–∑–≤–æ–ª—è—é—Ç –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∞–∂–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∞–ª—å–Ω—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–∞—Ö –≤ –º–æ–¥–µ–ª–∏ –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è, —É–ª—É—á—à–∞—è –∏—Ö —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –∫ –æ–±—É—á–µ–Ω–∏—é –∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—é. –í—ã–±–æ—Ä –º–µ—Ç–æ–¥–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø—Ä–∏–∑–Ω–∞–∫–∞ –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∑–∞–¥–∞—á–∏, –∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —ç—Ç–∏—Ö —Ç–µ—Ö–Ω–∏–∫ –º–æ–∂–µ—Ç –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –ø–æ–≤—ã—Å–∏—Ç—å –∫–∞—á–µ—Å—Ç–≤–æ –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏—è."""
            )
        updated_categorical_data = change_df[options_categorical]
        one_hot_encoding = create_toggle("one_hot_encoding_toggle", " One Hot encoding")
        if one_hot_encoding:
            one_hot_encoding_choose = st.radio(
                "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è one hot encoding:",
                ["–ù–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å", "–í—ã–±—Ä–∞—Ç—å –≤—Ä—É—á–Ω—É—é", "–í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã"],
                key=persist("radio_for_one_hot_encoding"),
            )
            if one_hot_encoding_choose == "–í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã":
                change_df = apply_one_hot_encoder(
                    change_df, updated_categorical_data.columns
                )

            elif one_hot_encoding_choose == "–í—ã–±—Ä–∞—Ç—å –≤—Ä—É—á–Ω—É—é":
                options = st.multiselect(
                    "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä one hot encoder: ",
                    updated_categorical_data.columns,
                    key=persist("select_manually_one_hot_encoding"),
                )
                change_df = apply_one_hot_encoder(change_df, options)
                updated_categorical_data = updated_categorical_data.drop(
                    options, axis=1
                )
            else:
                pass

        label_encoding = create_toggle("label_encoding_toggle", "Label encoding")
        if label_encoding:
            label_encoding_choose = st.radio(
                "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è label encoding:",
                ["–ù–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å", "–í—ã–±—Ä–∞—Ç—å –≤—Ä—É—á–Ω—É—é", "–í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã"],
                key=persist("radio_for_label_encoding"),
            )
            if label_encoding_choose == "–í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã":
                change_df = apply_label_encoder(
                    change_df, updated_categorical_data.columns
                )
            elif label_encoding_choose == "–í—ã–±—Ä–∞—Ç—å –≤—Ä—É—á–Ω—É—é":
                options = st.multiselect(
                    "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä label encoder: ",
                    updated_categorical_data.columns,
                    key=persist("select_manually_label_encoding"),
                )
                change_df = apply_label_encoder(change_df, options)
                updated_categorical_data = updated_categorical_data.drop(
                    options, axis=1
                )
            else:
                pass

        ordinal_encoding = create_toggle("ordinal_encoding_toggle", "Ordinal encoding")
        if ordinal_encoding:
            ordinal_encoding_choose = st.radio(
                "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è ordinal encoding:",
                ["–ù–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å", "–í—ã–±—Ä–∞—Ç—å –≤—Ä—É—á–Ω—É—é", "–í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã"],
                key=persist("radio_for_ordinal_encoding"),
            )
            if ordinal_encoding_choose == "–í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã":
                change_df = apply_ordinal_encoder(
                    change_df, updated_categorical_data.columns
                )
            elif ordinal_encoding_choose == "–í—ã–±—Ä–∞—Ç—å –≤—Ä—É—á–Ω—É—é":
                options = st.multiselect(
                    "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä ordinal encoder: ",
                    updated_categorical_data.columns,
                    key=persist("select_manually_ordinal_encoding"),
                )
                change_df = apply_ordinal_encoder(change_df, options)
                updated_categorical_data = updated_categorical_data.drop(
                    options, axis=1
                )
            else:
                pass

        st.subheader("4. –†–∞–±–æ—Ç–∞ —Å —á–∏—Å–ª–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏")
        with st.expander(
            "–ß—Ç–æ —Ç–∞–∫–æ–µ `–Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è`, `—Å—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∞—Ü–∏—è`, –∏ `–ª–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–∞—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è` –∏ –∑–∞—á–µ–º –æ–Ω–æ –Ω—É–∂–Ω–æ?"
        ):
            st.write(
                """–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è, —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∞—Ü–∏—è –∏ –ª–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–∞—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è ‚Äî —ç—Ç–æ –º–µ—Ç–æ–¥—ã –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –¥–ª—è –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è —á–∏—Å–ª–æ–≤—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –∫ –æ–±—â–µ–º—É –º–∞—Å—à—Ç–∞–±—É. –≠—Ç–∏ –º–µ—Ç–æ–¥—ã –ø–æ–º–æ–≥–∞—é—Ç —É–ª—É—á—à–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å –æ–±—É—á–µ–Ω–∏—è –º–∞—à–∏–Ω–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π, –¥–µ–ª–∞—è –µ–≥–æ –±–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–º –∏ —É–ª—É—á—à–∞—è –∫–∞—á–µ—Å—Ç–≤–æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π. –î–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä–µ–º—Å—è –ø–æ–¥—Ä–æ–±–Ω–µ–µ:

### –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è ‚Äî —ç—Ç–æ –ø—Ä–æ—Ü–µ—Å—Å –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ–±—ã –∏—Ö –∑–Ω–∞—á–µ–Ω–∏—è –ª–µ–∂–∞–ª–∏ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ, —á–∞—Å—Ç–æ –º–µ–∂–¥—É 0 –∏ 1. –≠—Ç–æ –¥–æ—Å—Ç–∏–≥–∞–µ—Ç—Å—è —Å –ø–æ–º–æ—â—å—é —Ñ—É–Ω–∫—Ü–∏–∏ min-max scaling.

**–ó–∞—á–µ–º —ç—Ç–æ –Ω—É–∂–Ω–æ**: –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –æ—Å–æ–±–µ–Ω–Ω–æ –ø–æ–ª–µ–∑–Ω–∞, –∫–æ–≥–¥–∞ –¥–∞–Ω–Ω—ã–µ —Å–æ–¥–µ—Ä–∂–∞—Ç –∞—Ç—Ä–∏–±—É—Ç—ã —Å —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ –º–∞—Å—à—Ç–∞–±–∞–º–∏, –∏ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã, —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ –∫ –≤–µ–ª–∏—á–∏–Ω–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤, —Ç–∞–∫–∏–µ –∫–∞–∫ k-NN, –Ω–µ–π—Ä–æ–Ω–Ω—ã–µ —Å–µ—Ç–∏, –∏–ª–∏ –∞–ª–≥–æ—Ä–∏—Ç–º—ã, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–µ –º–µ—Ä—ã —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è."""
            )
            st.write(
                """
### –°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∞—Ü–∏—è
–°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∞—Ü–∏—è ‚Äî —ç—Ç–æ –ø—Ä–æ—Ü–µ—Å—Å –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∫ –≤–∏–¥—É, –≥–¥–µ —Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ –ø—Ä–∏–∑–Ω–∞–∫–∞ —Ä–∞–≤–Ω–æ 0, –∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ ‚Äî 1. –≠—Ç–æ –¥–æ—Å—Ç–∏–≥–∞–µ—Ç—Å—è —Å –ø–æ–º–æ—â—å—é –º–µ—Ç–æ–¥–∞, –∏–Ω–æ–≥–¥–∞ –Ω–∞–∑—ã–≤–∞–µ–º–æ–≥–æ Z-score normalization.

**–ó–∞—á–µ–º —ç—Ç–æ –Ω—É–∂–Ω–æ**: –°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∞—Ü–∏—è –ø–æ–ª–µ–∑–Ω–∞, –∫–æ–≥–¥–∞ –¥–∞–Ω–Ω—ã–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ, –∏ –æ—Å–æ–±–µ–Ω–Ω–æ –≤–∞–∂–Ω–∞ –¥–ª—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤, –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞—é—â–∏—Ö –Ω–æ—Ä–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –≤—Ö–æ–¥–Ω—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤, —Ç–∞–∫–∏—Ö –∫–∞–∫ –ª–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è, –ª–∏–Ω–µ–π–Ω—ã–µ –∏ —Ä–∞–¥–∏–∞–ª—å–Ω—ã–µ SVM."""
            )
            st.write(
                """
### –õ–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–∞—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è
–õ–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–∞—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è ‚Äî —ç—Ç–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å –ø–æ–º–æ—â—å—é –ª–æ–≥–∞—Ä–∏—Ñ–º–∞, —á–∞—Å—Ç–æ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω–æ–≥–æ, —á—Ç–æ –ø–æ–º–æ–≥–∞–µ—Ç —É–º–µ–Ω—å—à–∏—Ç—å —Å–∫–æ—Å —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö. –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –ø–æ —Ñ–æ—Ä–º—É–ª–µ:"""
            )
        combined_object_string_cols = change_df.select_dtypes(
            include=["object", "string"]
        ).columns.tolist()
        col1, col2, col3 = st.columns(3)
        if len(combined_object_string_cols) > 0:
            status = True
        with col1:
            normalization = st.toggle(
                "–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è", key=persist("normalization_toggle")
            )
            if normalization:
                change_df = apply_min_max_scaling(change_df, change_df.columns)
        with col2:
            standartization = st.toggle(
                "–°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∞—Ü–∏—è", key=persist("standartization_toggle")
            )
            if standartization:
                change_df = apply_standardization(change_df, change_df.columns)
        with col3:
            log_transformation = st.toggle(
                "–õ–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–∞—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è",
                key=persist("log_transformation_toggle"),
            )
            if log_transformation:
                change_df = apply_log_transformation(change_df, change_df.columns)

        st.dataframe(change_df, hide_index=True)

        col1, col2, col3 = st.columns(3)
        with col1:
            if st.button("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è"):
                st.session_state["data"] = change_df
                st.success("–ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã.")
        with col2:
            if st.button("–û—á–∏—Å—Ç–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è"):
                st.session_state["data"] = st.session_state["original_data"].copy()
                reset_application_state()
                st.warning("–ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–±—Ä–æ—à–µ–Ω—ã")


def page_forth():
    if "uploaded" not in st.session_state:
        st.info("–°–Ω–∞—á–∞–ª–∞ –≤—ã –¥–æ–ª–∂–Ω—ã –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ")
    else:    
        st.title("–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞")
        complete_df = st.session_state["data"]
        st.subheader("–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –¥–∞—Ç–∞—Ñ—Ä–µ–π–º")
        st.dataframe(complete_df, hide_index=True)

        st.subheader("–ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤")
        color_theme_list = [
            "Blues",
            "viridis",
            "plasma",
            "inferno",
            "magma",
            "cividis",
            "Greys",
            "Purples",
            "Greens",
            "Oranges",
            "Reds",
            "YlOrBr",
            "YlOrRd",
            "OrRd",
            "PuRd",
            "RdPu",
            "BuPu",
            "GnBu",
            "PuBu",
            "YlGnBu",
            "PuBuGn",
            "BuGn",
            "YlGn",
            "PiYG",
            "PRGn",
            "BrBG",
            "PuOr",
            "RdGy",
            "RdBu",
            "RdYlBu",
            "RdYlGn",
            "Spectral",
            "coolwarm",
            "bwr",
            "seismic",
        ]
        color_for_corr = st.selectbox(
            "–í—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞",
            color_theme_list,
            key=persist("select_color_for_corr"),
        )
        correlation_matrix_visualize(complete_df, color_for_corr)

        st.subheader("1.–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞")
        plots = ["Line Plot", "Scatter Plot", "Histogram Plot", "Box Plot", "Density Plot"]
        visualizations = st.selectbox(
            "–í—ã–±–µ—Ä–∏—Ç–µ –≥—Ä–∞—Ñ–∏–∫ –∫–æ—Ç–æ—Ä—ã–π –≤—ã —Ö–æ—Ç–∏—Ç–µ —É–≤–∏–¥–µ—Ç—å",
            plots,
            key=persist("select_type_of_visualization_for_dataset"),
        )
        x_axis = st.selectbox(
            "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω –ø–æ –æ—Å–∏ X",
            complete_df.columns,
            key=persist("select_column_for_x_axis"),
        )
        y_axis = st.selectbox(
            "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω –ø–æ –æ—Å–∏ Y",
            complete_df.columns,
            key=persist("select_column_for_y_axis"),
        )
        color_theme_list = [
            "blues",
            "cividis",
            "greens",
            "inferno",
            "magma",
            "plasma",
            "reds",
            "turbo",
            "viridis",
        ]

        use_hue = create_toggle(
            "use_hue_toggle", "–í–∫–ª—é—á–∏—Ç—å –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫—É —Ç–æ—á–µ–∫ –¥–∞–Ω–Ω—ã—Ö –ø–æ —Ü–≤–µ—Ç—É"
        )

        if use_hue:
            hue = st.selectbox(
                "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä, —Å –ø–æ–º–æ—â—å—é –∫–æ—Ç–æ—Ä–æ–≥–æ –±—É–¥—É—Ç –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å—Å—è —Ç–æ—á–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ —Ü–≤–µ—Ç—É",
                complete_df.columns,
                key="select_hue",  # Assuming persist() function is defined elsewhere to handle session state
            )
            selected_color_theme = st.selectbox(
                "Select a color theme", color_theme_list, key=persist("select_color_theme")
            )
        else:
            hue = None
            selected_color_theme = st.color_picker(
                "Pick A Color", "#4bdbff", key=persist("color")
            )

        # Then, depending on the type of visualization selected by the user:
        if visualizations == "Line Plot":
            line_chart(
                complete_df, x_axis, y_axis, input_color_theme=selected_color_theme, hue=hue
            )
        elif visualizations == "Scatter Plot":
            scatter_plot(
                complete_df, x_axis, y_axis, input_color_theme=selected_color_theme, hue=hue
            )
        elif visualizations == "Histogram Plot":
            histogram(complete_df, x_axis, input_color_theme=selected_color_theme, hue=hue)
        elif visualizations == "Box Plot":
            box_plot(
                complete_df, x_axis, y_axis, input_color_theme=selected_color_theme, hue=hue
            )
        elif visualizations == "Density Plot":
            density_plot(
                complete_df, x_axis, input_color_theme=selected_color_theme, hue=hue
            )


def page_fifth():
    if "uploaded" not in st.session_state:
        st.info("–°–Ω–∞—á–∞–ª–∞ –≤—ã –¥–æ–ª–∂–Ω—ã –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ")
    else:
        st.title("–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –º–æ–¥–µ–ª–∏")
        regression_models = [
            "Linear Regression",
            "Decision Tree Regression",
            "Random Forest Regression",
            "Support Vector Machine Regression",
            "Gradient Boosting Regression",
            "Multi Layer Perceptron Regression"
        ]
        classification_models = [
            "Logistic Regression",
            "Decision Tree CLassifier",
            "Random Forest Classification",
            "Support Vector Machine CLassification",
            "Gradient Boosting Classification",
            "Multi Layer Perceptron Classifier"
        ]

        complete_df = st.session_state["data"]
        st.subheader("–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –¥–∞—Ç–∞—Ñ—Ä–µ–π–º")
        st.dataframe(complete_df, hide_index=True)
        st.subheader("1.–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–π –∏ —Ç–µ—Å—Ç–æ–≤—ã–π –¥–∞—Ç–∞—Ñ—Ä–µ–π–º")
        y_column = st.selectbox(
            "–í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª–µ–≤–æ–π –ø–∞—Ä–∞–º–µ—Ç—Ä, –∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ—Ç–æ—Ä–æ–≥–æ –±—É–¥—É—Ç —Å–ø—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω—ã:",
            complete_df.columns,
            key=persist("select_y_column"),
        )
        X = delete_columns(complete_df, y_column)
        y = complete_df[y_column]
        col1, col2, col3 = st.columns([5, 0.3, 1])
        with col1:
            st.subheader("X:")
            st.dataframe(X, hide_index=True)
            st.write("–†–∞–∑–º–µ—Ä –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞ :", X.shape)
        with col3:
            st.subheader("y:")
            st.dataframe(y, hide_index=True)
            st.write("–†–∞–∑–º–µ—Ä –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞ :", y.shape[0])

        size = st.slider(
            "–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–º–µ—Ä —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞:",
            0.0,
            1.0,
            0.2,
            step=0.01,
            key=persist("slider_size_of_test_dataset"),
        )
        st.write(f"–†–∞–∑–º–µ—Ä —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞ {size * 100} % –æ—Ç –æ–±—â–µ–≥–æ –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞")
        X_train, X_test, y_train, y_test = custom_train_test_split(X, y, size=size)

        col1, col2, col3 = st.columns([5, 0.3, 1])
        with col1:
            st.subheader("X_train:")
            st.dataframe(X_train, hide_index=True)
            st.write("–†–∞–∑–º–µ—Ä –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞ :", X_train.shape)
        with col3:
            st.subheader("y_train:")
            st.dataframe(y_train, hide_index=True)
            st.write("–†–∞–∑–º–µ—Ä –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞ :", y_train.shape[0])
        st.divider()
        col4, col5, col6 = st.columns([5, 0.3, 1])
        with col4:
            st.subheader("X_test:")
            st.dataframe(X_test, hide_index=True)
            st.write("–†–∞–∑–º–µ—Ä –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞ :", X_test.shape)
        with col6:
            st.subheader("y_test:")
            st.dataframe(y_test, hide_index=True)
            st.write("–†–∞–∑–º–µ—Ä –¥–∞—Ç–∞—Ñ—Ä–µ–π–º–∞ :", y_test.shape[0])

        st.subheader("2.–í—ã–±–æ—Ä –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è")

        model = None

        type_of_task_radio = st.radio(
            "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∑–∞–¥–∞—á–∏:",
            ["–†–µ–≥—Ä–µ—Å—Å–∏—è", "–ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è"],
            key=persist("type_of_task_radio"),
        )
        if type_of_task_radio == "–†–µ–≥—Ä–µ—Å—Å–∏—è":
            options_regression = st.selectbox(
                "–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –†–µ–≥—Ä–µ—Å—Å–∏–∏: ",
                regression_models,
                key=persist("select_regression_model"),
            )
            if options_regression == "Linear Regression":
                model = custom_linear_regression()
            elif options_regression == "Decision Tree Regression":
                options_decision_tree_regression = st.radio(
                    "–°–¥–µ–ª–∞–π—Ç–µ –≤—ã–±–æ—Ä:",
                    ["–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é", "–í—ã–±—Ä–∞—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –º–æ–¥–µ–ª—å"],
                    key=persist("choose_parameters_for_decision_tree_regression"),
                )
                if options_decision_tree_regression == "–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é":
                    col1, col2 = st.columns(2)
                    with col1:
                        max_depth = st.number_input(
                            "`max_depth` –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ –¥–µ—Ä–µ–≤–∞",
                            1,
                            100,
                            3,
                            key=persist("number_for_decision_tree_regression_max_depth"),
                        )
                    with col2:
                        min_samples_split = st.number_input(
                            "`min_samples_split` –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–∑—Ü–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è —Ä–∞–∑–±–∏–µ–Ω–∏—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —É–∑–ª–∞",
                            2,
                            100,
                            2,
                            key=persist(
                                "number_for_decision_tree_regression_min_samples_split"
                            ),
                        )
                    col3, col4 = st.columns(2)
                    with col3:
                        min_samples_leaf = st.number_input(
                            "`min_samples_leaf` –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–∑—Ü–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –≤ —É–∑–ª–µ –ª–∏—Å—Ç–∞",
                            1,
                            100,
                            1,
                            key=persist(
                                "number_for_decision_tree_regression_min_samples_leaf"
                            ),
                        )
                    with col4:
                        ccp_alpha = st.slider(
                            "`ccp_alpha` –ü–∞—Ä–∞–º–µ—Ç—Ä —Å–ª–æ–∂–Ω–æ—Å—Ç–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –¥–ª—è –æ–±—Ä–µ–∑–∫–∏ –ø–æ –ø—Ä–∏–Ω—Ü–∏–ø—É –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å - —Å–ª–æ–∂–Ω–æ—Å—Ç—å",
                            0.0,
                            1.0,
                            1.0,
                            step=0.01,
                            key=persist("slider_decision_tree_regression_ccp_alpha"),
                        )
                    criterion_for_decision_tree_regression = [
                        "squared_error",
                        "friedman_mse",
                        "absolute_error",
                        "poisson",
                    ]
                    criterion = st.selectbox(
                        "`criterion` –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è",
                        criterion_for_decision_tree_regression,
                        key=persist("select_criterion_decision_tree_regression"),
                    )

                    model = custom_decision_tree_regression(
                        criterion_c=criterion,
                        max_depth_c=max_depth,
                        min_samples_split_c=min_samples_split,
                        min_samples_leaf_c=min_samples_leaf,
                        ccp_alpha_c=ccp_alpha,
                    )
                else:
                    model = DecisionTreeRegressor()

            elif options_regression == "Random Forest Regression":
                options_random_forest_regression = st.radio(
                    "–°–¥–µ–ª–∞–π—Ç–µ –≤—ã–±–æ—Ä:",
                    ["–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é", "–í—ã–±—Ä–∞—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –º–æ–¥–µ–ª—å"],
                    key=persist("choose_parameters_for_random_forest_regression"),
                )
                if options_random_forest_regression == "–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é":
                    n_estimators = st.slider(
                        "`n_estimators` –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ—Ä–µ–≤—å–µ–≤ –≤ –ª–µ—Å—É",
                        50,
                        1000,
                        100,
                        key=persist("number_for_random_forest_regression_n_estimators"),
                    )
                    col1, col2 = st.columns(2)
                    with col1:
                        max_depth = st.number_input(
                            "`max_depth` –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ –∫–∞–∂–¥–æ–≥–æ –¥–µ—Ä–µ–≤–∞",
                            1,
                            100,
                            3,
                            key=persist("number_for_random_forest_regression_max_depth"),
                        )
                    with col2:
                        min_samples_split = st.number_input(
                            "`min_samples_split` –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–∑—Ü–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è —Ä–∞–∑–±–∏–µ–Ω–∏—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —É–∑–ª–∞",
                            2,
                            100,
                            2,
                            key=persist(
                                "number_for_random_forest_regression_min_samples_split"
                            ),
                        )
                    col3, col4 = st.columns(2)
                    with col3:
                        min_samples_leaf = st.number_input(
                            "`min_samples_leaf` –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–∑—Ü–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –≤ —É–∑–ª–µ –ª–∏—Å—Ç–∞",
                            1,
                            100,
                            1,
                            key=persist(
                                "number_for_random_forest_regression_min_samples_leaf"
                            ),
                        )
                    with col4:
                        ccp_alpha = st.slider(
                            "`ccp_alpha` –ü–∞—Ä–∞–º–µ—Ç—Ä —Å–ª–æ–∂–Ω–æ—Å—Ç–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –¥–ª—è –æ–±—Ä–µ–∑–∫–∏ –ø–æ –ø—Ä–∏–Ω—Ü–∏–ø—É –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å - —Å–ª–æ–∂–Ω–æ—Å—Ç—å",
                            0.0,
                            1.0,
                            0.0,
                            step=0.01,
                            key=persist("slider_random_forest_regression_ccp_alpha"),
                        )
                    criterion_for_random_forest_regression = [
                        "squared_error",
                        "friedman_mse",
                        "absolute_error",
                        "poisson",
                    ]
                    criterion = st.selectbox(
                        "`criterion` –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è",
                        criterion_for_random_forest_regression,
                        key=persist("select_criterion_random_forest_regression"),
                    )

                    model = custom_random_forest_regression(
                        n_estimators,
                        criterion,
                        max_depth,
                        min_samples_split,
                        min_samples_leaf,
                        ccp_alpha,
                    )
                else:
                    model = RandomForestRegressor()

            elif options_regression == "Support Vector Machine Regression":
                options_svm_regression = st.radio(
                    "–°–¥–µ–ª–∞–π—Ç–µ –≤—ã–±–æ—Ä:",
                    ["–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é", "–í—ã–±—Ä–∞—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –º–æ–¥–µ–ª—å"],
                    key=persist("choose_parameters_for_svm_regression"),
                )
                if options_svm_regression == "–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é":
                    col1, col2 = st.columns(2)
                    with col1:
                        kernel = st.selectbox(
                            "`kernel` –£–∫–∞–∑—ã–≤–∞–µ—Ç —Ç–∏–ø —è–¥—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤ –∞–ª–≥–æ—Ä–∏—Ç–º–µ.",
                            ["linear", "poly", "rbf", "sigmoid", "precomputed"],
                            key=persist("select_kernel_svm_regression"),
                        )
                    with col2:
                        degree = st.number_input(
                            "`degree` –°—Ç–µ–ø–µ–Ω—å –ø–æ–ª–∏–Ω–æ–º–∏–∞–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ —è–¥—Ä–∞ ('poly')",
                            1,
                            10,
                            3,
                            key=persist("number_for_svm_regression_degree"),
                        )
                    model = custom_svr(kernel, degree)
                else:
                    model = SVR()
            elif options_regression == "Gradient Boosting Regression":
                options_gbc_regression = st.radio(
                    "–°–¥–µ–ª–∞–π—Ç–µ –≤—ã–±–æ—Ä:",
                    ["–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é", "–í—ã–±—Ä–∞—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –º–æ–¥–µ–ª—å"],
                    key=persist("choose_parameters_for_gbc_regression"),
                )
                if options_gbc_regression == "–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é":
                    col1, col2 = st.columns(2)
                    with col1:
                        loss = st.selectbox(
                            "`loss` –§—É–Ω–∫—Ü–∏—è –ø–æ—Ç–µ—Ä—å, –∫–æ—Ç–æ—Ä—É—é –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å",
                            ["squared_error", "absolute_error", "huber", "quantile"],
                            key=persist("select_loss_gbc_regression"),
                        )
                    with col2:
                        learning_rate = st.slider(
                            "`learning_rate` –°–∫–æ—Ä–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è —É–º–µ–Ω—å—à–∞–µ—Ç –≤–∫–ª–∞–¥ –∫–∞–∂–¥–æ–≥–æ –¥–µ—Ä–µ–≤–∞ –Ω–∞ –≤–µ–ª–∏—á–∏–Ω—É learning_rate",
                            0.0,
                            1.0,
                            0.1,
                            step=0.01,
                            key=persist("number_for_gbc_regression_learning_rate"),
                        )
                    n_estimators = st.slider(
                        "`n_estimators` –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ—Ä–µ–≤—å–µ–≤ –≤ –ª–µ—Å—É",
                        50,
                        1000,
                        100,
                        key=persist("number_for_gbc_regression_n_estimators"),
                    )
                    col3, col4 = st.columns(2)
                    with col3:
                        max_depth = st.number_input(
                            "`max_depth` –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ –∫–∞–∂–¥–æ–≥–æ –¥–µ—Ä–µ–≤–∞",
                            1,
                            100,
                            3,
                            key=persist("number_for_gbc_regression_max_depth"),
                        )
                    with col4:
                        min_samples_split = st.number_input(
                            "`min_samples_split` –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–∑—Ü–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è —Ä–∞–∑–±–∏–µ–Ω–∏—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —É–∑–ª–∞",
                            2,
                            100,
                            2,
                            key=persist("number_for_gbc_regression_min_samples_split"),
                        )
                    col5, col6 = st.columns(2)
                    with col5:
                        min_samples_leaf = st.number_input(
                            "`min_samples_leaf` –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–∑—Ü–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –≤ —É–∑–ª–µ –ª–∏—Å—Ç–∞",
                            1,
                            100,
                            1,
                            key=persist("number_for_gbc_regression_min_samples_leaf"),
                        )
                    with col6:
                        ccp_alpha = st.slider(
                            "`ccp_alpha` –ü–∞—Ä–∞–º–µ—Ç—Ä —Å–ª–æ–∂–Ω–æ—Å—Ç–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –¥–ª—è –æ–±—Ä–µ–∑–∫–∏ –ø–æ –ø—Ä–∏–Ω—Ü–∏–ø—É –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å - —Å–ª–æ–∂–Ω–æ—Å—Ç—å",
                            0.0,
                            1.0,
                            0.0,
                            step=0.01,
                            key=persist("slider_gbc_regression_ccp_alpha"),
                        )
                    criterion_for_random_forest_classification = [
                        "friedman_mse",
                        "squared_error",
                    ]
                    criterion = st.selectbox(
                        "`criterion` –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è",
                        criterion_for_random_forest_classification,
                        key=persist("select_criterion_gbc_regression"),
                    )

                    model = custom_gbr(
                        loss_c=loss,
                        learning_rate_c=learning_rate,
                        n_estimators_c=n_estimators,
                        criterion_c=criterion,
                        max_depth_c=max_depth,
                        min_samples_split_c=min_samples_split,
                        min_samples_leaf_c=min_samples_leaf,
                        ccp_alpha_c=ccp_alpha,
                    )
                else:
                    model = GradientBoostingRegressor()
            else:
                options_mlp_regression = st.radio(
                    "–°–¥–µ–ª–∞–π—Ç–µ –≤—ã–±–æ—Ä:",
                    ["–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é", "–í—ã–±—Ä–∞—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –º–æ–¥–µ–ª—å"],
                    key=persist("choose_parameters_for_mlpc"),
                )
                if options_mlp_regression == "–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é":
                    col1, col2 = st.columns(2)
                    with col1:
                        activation = st.selectbox("`activation` –§—É–Ω–∫—Ü–∏—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –¥–ª—è —Å–∫—Ä—ã—Ç–æ–≥–æ —Å–ª–æ—è", ["relu", "logistic", "tanh", "identity"], key=persist("select_activation_mlpc"))
                    with col2:
                        solver = st.selectbox("`solver` –†–µ—à–∞—é—â–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –≤–µ—Å–∞", ["adam", "lbfgs", "sgd"],  key=persist("select_solver_mlpc"))
                    model = custom_mlp_regressor(activation_func_c=activation, solver_c=solver)
                else:
                    model = MLPRegressor()
                
        else:
            options_clf = st.selectbox(
                "–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏: ",
                classification_models,
                key=persist("select_classification_model"),
            )
            if options_clf == "Logistic Regression":
                options_logistic_regression = st.radio(
                    "–°–¥–µ–ª–∞–π—Ç–µ –≤—ã–±–æ—Ä:",
                    ["–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é", "–í—ã–±—Ä–∞—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –º–æ–¥–µ–ª—å"],
                    key=persist("choose_parameters_for_logistic_regression"),
                )
                if options_logistic_regression == "–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é":
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        C = st.slider(
                            "`C` –û–±—Ä–∞—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å–∏–ª—ã —Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏–∏",
                            0.0,
                            1.0,
                            1.0,
                            step=0.01,
                            key=persist("slider_for_logistic_regression_C"),
                        )
                    with col2:
                        max_iter = st.number_input(
                            "` max_iter` –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —Ä–µ—à–∞—Ç–µ–ª–µ–π",
                            10,
                            1000,
                            100,
                            key=persist("number_for_logistic_regression_max_iter"),
                        )
                    with col3:
                        l1_ratio = st.slider(
                            "`l1_ratio` –ü–∞—Ä–∞–º–µ—Ç—Ä —Å–º–µ—à–∏–≤–∞–Ω–∏—è Elastic-Net",
                            0.0,
                            1.0,
                            1.0,
                            step=0.01,
                            key=persist("slider_for_logistic_regression_l1_ratio"),
                        )

                    model = custom_logistic_regression(
                        C_c=C, max_iter_c=max_iter, l1_ratio_c=l1_ratio
                    )
                else:
                    model = LogisticRegression()
            if options_clf == "Decision Tree CLassifier":
                options_decision_tree_classification = st.radio(
                    "–°–¥–µ–ª–∞–π—Ç–µ –≤—ã–±–æ—Ä:",
                    ["–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é", "–í—ã–±—Ä–∞—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –º–æ–¥–µ–ª—å"],
                    key=persist("choose_parameters_for_decision_tree_classification"),
                )
                if options_decision_tree_classification == "–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é":
                    col1, col2 = st.columns(2)
                    with col1:
                        max_depth = st.number_input(
                            "`max_depth` –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ –¥–µ—Ä–µ–≤–∞",
                            1,
                            100,
                            3,
                            key=persist(
                                "number_for_decision_tree_classification_max_depth"
                            ),
                        )
                    with col2:
                        min_samples_split = st.number_input(
                            "`min_samples_split` –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–∑—Ü–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è —Ä–∞–∑–±–∏–µ–Ω–∏—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —É–∑–ª–∞",
                            2,
                            100,
                            2,
                            key=persist(
                                "number_for_decision_tree_classification_min_samples_split"
                            ),
                        )
                    col3, col4 = st.columns(2)
                    with col3:
                        min_samples_leaf = st.number_input(
                            "`min_samples_leaf` –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–∑—Ü–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –≤ —É–∑–ª–µ –ª–∏—Å—Ç–∞",
                            1,
                            100,
                            1,
                            key=persist(
                                "number_for_decision_tree_classification_min_samples_leaf"
                            ),
                        )
                    with col4:
                        ccp_alpha = st.slider(
                            "`ccp_alpha` –ü–∞—Ä–∞–º–µ—Ç—Ä —Å–ª–æ–∂–Ω–æ—Å—Ç–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –¥–ª—è –æ–±—Ä–µ–∑–∫–∏ –ø–æ –ø—Ä–∏–Ω—Ü–∏–ø—É –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å - —Å–ª–æ–∂–Ω–æ—Å—Ç—å",
                            0.0,
                            1.0,
                            0.0,
                            step=0.01,
                            key=persist("slider_decision_tree_classification_ccp_alpha"),
                        )
                    criterion_for_decision_tree_classification = [
                        "gini",
                        "entropy",
                        "log_loss",
                    ]
                    criterion = st.selectbox(
                        "`criterion` –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è",
                        criterion_for_decision_tree_classification,
                        key=persist("select_criterion_decision_tree_classification"),
                    )

                    model = custom_decision_tree_classification(
                        criterion_c=criterion,
                        max_depth_c=max_depth,
                        min_samples_split_c=min_samples_split,
                        min_samples_leaf_c=min_samples_leaf,
                        ccp_alpha_c=ccp_alpha,
                    )
                else:
                    model = DecisionTreeClassifier()

            elif options_clf == "Random Forest Classification":
                options_random_forest_classification = st.radio(
                    "–°–¥–µ–ª–∞–π—Ç–µ –≤—ã–±–æ—Ä:",
                    ["–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é", "–í—ã–±—Ä–∞—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –º–æ–¥–µ–ª—å"],
                    key=persist("choose_parameters_for_random_forest_classification"),
                )
                if options_random_forest_classification == "–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é":
                    n_estimators = st.slider(
                        "`n_estimators` –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ—Ä–µ–≤—å–µ–≤ –≤ –ª–µ—Å—É",
                        50,
                        1000,
                        100,
                        key=persist("number_for_random_forest_classification_n_estimators"),
                    )
                    col1, col2 = st.columns(2)
                    with col1:
                        max_depth = st.number_input(
                            "`max_depth` –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ –∫–∞–∂–¥–æ–≥–æ –¥–µ—Ä–µ–≤–∞",
                            1,
                            100,
                            3,
                            key=persist(
                                "number_for_random_forest_classification_max_depth"
                            ),
                        )
                    with col2:
                        min_samples_split = st.number_input(
                            "`min_samples_split` –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–∑—Ü–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è —Ä–∞–∑–±–∏–µ–Ω–∏—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —É–∑–ª–∞",
                            2,
                            100,
                            2,
                            key=persist(
                                "number_for_random_forest_classification_min_samples_split"
                            ),
                        )
                    col3, col4 = st.columns(2)
                    with col3:
                        min_samples_leaf = st.number_input(
                            "`min_samples_leaf` –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–∑—Ü–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –≤ —É–∑–ª–µ –ª–∏—Å—Ç–∞",
                            1,
                            100,
                            1,
                            key=persist(
                                "number_for_random_forest_classification_min_samples_leaf"
                            ),
                        )
                    with col4:
                        ccp_alpha = st.slider(
                            "`ccp_alpha` –ü–∞—Ä–∞–º–µ—Ç—Ä —Å–ª–æ–∂–Ω–æ—Å—Ç–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –¥–ª—è –æ–±—Ä–µ–∑–∫–∏ –ø–æ –ø—Ä–∏–Ω—Ü–∏–ø—É –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å - —Å–ª–æ–∂–Ω–æ—Å—Ç—å",
                            0.0,
                            1.0,
                            0.0,
                            step=0.01,
                            key=persist("slider_random_forest_classification_ccp_alpha"),
                        )
                    criterion_for_random_forest_classification = [
                        "gini",
                        "entropy",
                        "log_loss",
                    ]
                    criterion = st.selectbox(
                        "`criterion` –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è",
                        criterion_for_random_forest_classification,
                        key=persist("select_criterion_random_forest_classification"),
                    )

                    model = custom_random_forest_classification(
                        n_estimators,
                        criterion,
                        max_depth,
                        min_samples_split,
                        min_samples_leaf,
                        ccp_alpha,
                    )
                else:
                    model = RandomForestClassifier()

            elif options_clf == "Support Vector Machine CLassification":
                options_svm_classification = st.radio(
                    "–°–¥–µ–ª–∞–π—Ç–µ –≤—ã–±–æ—Ä:",
                    ["–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é", "–í—ã–±—Ä–∞—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –º–æ–¥–µ–ª—å"],
                    key=persist("choose_parameters_for_svm_classification"),
                )
                if options_svm_classification == "–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é":
                    col1, col2 = st.columns(2)
                    with col1:
                        kernel = st.selectbox(
                            "`kernel` –£–∫–∞–∑—ã–≤–∞–µ—Ç —Ç–∏–ø —è–¥—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤ –∞–ª–≥–æ—Ä–∏—Ç–º–µ.",
                            ["linear", "poly", "rbf", "sigmoid", "precomputed"],
                            key=persist("select_kernel_svm_classification"),
                        )
                    with col2:
                        degree = st.number_input(
                            "`degree` –°—Ç–µ–ø–µ–Ω—å –ø–æ–ª–∏–Ω–æ–º–∏–∞–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ —è–¥—Ä–∞ ('poly')",
                            1,
                            10,
                            3,
                            key=persist("number_for_svm_classification_degree"),
                        )
                    model = custom_svc(kernel, degree)
                else:
                    model = SVC()
            elif options_clf == "Gradient Boosting Classification":
                options_gbc_classification = st.radio(
                    "–°–¥–µ–ª–∞–π—Ç–µ –≤—ã–±–æ—Ä:",
                    ["–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é", "–í—ã–±—Ä–∞—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –º–æ–¥–µ–ª—å"],
                    key=persist("choose_parameters_for_gbc_classification"),
                )
                if options_gbc_classification == "–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é":
                    col1, col2 = st.columns(2)
                    with col1:
                        loss = st.selectbox(
                            "`loss` –§—É–Ω–∫—Ü–∏—è –ø–æ—Ç–µ—Ä—å, –∫–æ—Ç–æ—Ä—É—é –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å",
                            ["log_loss", "exponential"],
                            key=persist("select_loss_gbc_classification"),
                        )
                    with col2:
                        learning_rate = st.slider(
                            "`learning_rate` –°–∫–æ—Ä–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è —É–º–µ–Ω—å—à–∞–µ—Ç –≤–∫–ª–∞–¥ –∫–∞–∂–¥–æ–≥–æ –¥–µ—Ä–µ–≤–∞ –Ω–∞ –≤–µ–ª–∏—á–∏–Ω—É learning_rate",
                            0.0,
                            1.0,
                            0.1,
                            step=0.01,
                            key=persist("number_for_gbc_classification_learning_rate"),
                        )
                    n_estimators = st.slider(
                        "`n_estimators` –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ—Ä–µ–≤—å–µ–≤ –≤ –ª–µ—Å—É",
                        50,
                        1000,
                        100,
                        key=persist("number_for_gbc_classification_n_estimators"),
                    )
                    col3, col4 = st.columns(2)
                    with col3:
                        max_depth = st.number_input(
                            "`max_depth` –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ –∫–∞–∂–¥–æ–≥–æ –¥–µ—Ä–µ–≤–∞",
                            1,
                            100,
                            3,
                            key=persist("number_for_gbc_classification_max_depth"),
                        )
                    with col4:
                        min_samples_split = st.number_input(
                            "`min_samples_split` –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–∑—Ü–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è —Ä–∞–∑–±–∏–µ–Ω–∏—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —É–∑–ª–∞",
                            2,
                            100,
                            2,
                            key=persist("number_for_gbc_classification_min_samples_split"),
                        )
                    col5, col6 = st.columns(2)
                    with col5:
                        min_samples_leaf = st.number_input(
                            "`min_samples_leaf` –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞–∑—Ü–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –≤ —É–∑–ª–µ –ª–∏—Å—Ç–∞",
                            1,
                            100,
                            1,
                            key=persist("number_for_gbc_classification_min_samples_leaf"),
                        )
                    with col6:
                        ccp_alpha = st.slider(
                            "`ccp_alpha` –ü–∞—Ä–∞–º–µ—Ç—Ä —Å–ª–æ–∂–Ω–æ—Å—Ç–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –¥–ª—è –æ–±—Ä–µ–∑–∫–∏ –ø–æ –ø—Ä–∏–Ω—Ü–∏–ø—É –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å - —Å–ª–æ–∂–Ω–æ—Å—Ç—å",
                            0.0,
                            1.0,
                            0.0,
                            step=0.01,
                            key=persist("slider_gbc_classification_ccp_alpha"),
                        )
                    criterion_for_random_forest_classification = [
                        "friedman_mse",
                        "squared_error",
                    ]
                    criterion = st.selectbox(
                        "`criterion` –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è",
                        criterion_for_random_forest_classification,
                        key=persist("select_criterion_gbc_classification"),
                    )

                    model = custom_gbc(
                        loss_c=loss,
                        learning_rate_c=learning_rate,
                        n_estimators_c=n_estimators,
                        criterion_c=criterion,
                        max_depth_c=max_depth,
                        min_samples_split_c=min_samples_split,
                        min_samples_leaf_c=min_samples_leaf,
                        ccp_alpha_c=ccp_alpha,
                    )
                else:
                    model = GradientBoostingClassifier()
            else:
                options_mlp_classification = st.radio(
                    "–°–¥–µ–ª–∞–π—Ç–µ –≤—ã–±–æ—Ä:",
                    ["–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é", "–í—ã–±—Ä–∞—Ç—å –¥–µ—Ñ–æ–ª—Ç–Ω—É—é –º–æ–¥–µ–ª—å"],
                    key=persist("choose_parameters_for_mlpc"),
                )
                if options_mlp_classification == "–í—ã–±—Ä–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä—É—á–Ω—É—é":
                    col1, col2 = st.columns(2)
                    with col1:
                        activation = st.selectbox("`activation` –§—É–Ω–∫—Ü–∏—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –¥–ª—è —Å–∫—Ä—ã—Ç–æ–≥–æ —Å–ª–æ—è", ["relu", "logistic", "tanh", "identity"], key=persist("select_activation_mlpc"))
                    with col2:
                        solver = st.selectbox("`solver` –†–µ—à–∞—é—â–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –≤–µ—Å–∞", ["adam", "lbfgs", "sgd"],  key=persist("select_solver_mlpc"))
                    col1, col2 = st.columns(2)
                    with col1:
                        number_layers = st.slider("`hidden_layer` –≠—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∫—Ä—ã—Ç—ã—Ö –Ω–µ–π—Ä–æ–Ω–æ–≤ –≤ —Å–ª–æ–µ", 32, 256, 1, key=persist("select_layers_mlpc"))
                    model = custom_mlp_classifier(activation_func_c=activation, solver_c=solver, number_layers_c=number_layers)
                else:
                    model = MLPClassifier()
                
                
        st.write(model)

        color_theme_list = [
            "Blues",
            "viridis",
            "plasma",
            "inferno",
            "magma",
            "cividis",
            "Greys",
            "Purples",
            "Greens",
            "Oranges",
            "Reds",
            "YlOrBr",
            "YlOrRd",
            "OrRd",
            "PuRd",
            "RdPu",
            "BuPu",
            "GnBu",
            "PuBu",
            "YlGnBu",
            "PuBuGn",
            "BuGn",
            "YlGn",
            "PiYG",
            "PRGn",
            "BrBG",
            "PuOr",
            "RdGy",
            "RdBu",
            "RdYlBu",
            "RdYlGn",
            "Spectral",
            "coolwarm",
            "bwr",
            "seismic",
        ]
        show_results_visualizations = False

        if st.checkbox("–û–±—É—á–∏—Ç—å –∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –º–æ–¥–µ–ª—å", key=persist("checkbox_model_see")):
            show_results_visualizations = True
            model, pred = train_and_predict(model, X_train, y_train, X_test)
            if type_of_task_radio == "–†–µ–≥—Ä–µ—Å—Å–∏—è":
                r2 = r2_score(y_test, pred)
                mae = mean_absolute_error(y_test, pred)
                mse = mean_squared_error(y_test, pred)
                regression_score = pd.DataFrame(
                    {"R_2": r2, "Mean Absolute Error": mae, "Mean Squared Error": mse},
                    index=[0],
                )
                st.dataframe(regression_score, hide_index=True)
            else:
                acc = accuracy_score(y_test, pred)
                if y_test.nunique()!=2:
                    f1 = f1_score(y_test, pred, average='micro')
                    precision = precision_score(y_test, pred, average='micro')
                    recall = recall_score(y_test, pred, average='micro')
                else:
                    f1 = f1_score(y_test, pred)
                    precision = precision_score(y_test, pred)
                    recall = recall_score(y_test, pred)
                classification_score = pd.DataFrame(
                    {
                        "Accuracy": acc,
                        "F1_score": f1,
                        "Precision": precision,
                        "Recall": recall,
                    },
                    index=[0],
                )
                st.write("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã:")
                st.dataframe(classification_score, hide_index=True)

        # Assuming your model is named `model` and is already trained
        filename = "Completed_model.joblib"
        joblib.dump(model, filename)  # Save the model to a file

        # Open the file in binary mode to pass to the download button
        with open(filename, "rb") as file:
            st.download_button(
                label="C–∫–∞—á–∞—Ç—å –≥–æ—Ç–æ–≤—É—é –º–æ–¥–µ–ª—å",
                data=file,
                file_name=filename,
                mime="application/octet-stream",
            )

        st.subheader("3.–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤")
        if show_results_visualizations:
            if type_of_task_radio == "–†–µ–≥—Ä–µ—Å—Å–∏—è":
                color = st.color_picker(
                    "–í—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç", "#00f900", key=persist("color_for_result")
                )
                regression_result_visualization(y_test, pred, color)
            else:
                color = st.selectbox(
                    "–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ö–µ–º—É —Ü–≤–µ—Ç–æ–≤ –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏", color_theme_list
                )
                confusion_matrix_visualization(y_test, pred, color)
        else:
            st.info("–°–Ω–∞—á–∞–ª–∞ –Ω—É–∂–Ω–æ –æ–±—É—á–∏—Ç—å –º–æ–¥–µ–ª—å –∏ –ø–æ–ª—É—á–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã")


_PERSIST_STATE_KEY = f"{__name__}_PERSIST"


def persist(key: str) -> str:
    """Mark widget state as persistent."""
    if _PERSIST_STATE_KEY not in _state:
        _state[_PERSIST_STATE_KEY] = set()

    _state[_PERSIST_STATE_KEY].add(key)

    return key


initial_state = {"uploaded": True}

initial_state_data = {"uploaded": False}


def load_widget_state():
    """Load persistent widget state."""
    if _PERSIST_STATE_KEY in _state:
        _state.update(
            {
                key: value
                for key, value in _state.items()
                if key in _state[_PERSIST_STATE_KEY]
            }
        )


def reset_application_state():
    global _state
    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É–¥–∞–ª–µ–Ω—ã
    preserved_values = {
        key: _state[key] for key in ["data", "original_data"] if key in _state
    }

    # –û—á–∏—Å—Ç–∫–∞ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    _state.clear()

    # –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    _state.update(
        initial_state.copy()
    )  # –ò—Å–ø–æ–ª—å–∑—É–µ–º .copy() –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ –∏—Å—Ö–æ–¥–Ω–æ–º —Å–ª–æ–≤–∞—Ä–µ

    # –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
    _state.update(preserved_values)
    st.rerun()


def reset_application_state_with_data():
    global _state

    _state.update(
        initial_state_data.copy()
    )  # –ò—Å–ø–æ–ª—å–∑—É–µ–º .copy() –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ –∏—Å—Ö–æ–¥–Ω–æ–º —Å–ª–æ–≤–∞—Ä–µ

    _state.clear()

    st.rerun()


def upload_file():
    """
    Presents a file uploader widget and returns the uploaded file object.

    This function creates a file uploader in a Streamlit app with the specified prompt message.
    Users can upload a file through the UI. If a file is uploaded, the function returns the
    file object provided by Streamlit, allowing further processing of the file. If no file is
    uploaded, the function returns None.

    Returns:
    - uploaded_file (UploadedFile or None): The file object uploaded by the user through the
      file uploader widget. The object contains methods and attributes to access and read the file's
      content. Returns None if no file has been uploaded.

    Example usage:
    ```
    uploaded_file = upload_file()
    if uploaded_file is not None:
        # Process the file
        st.write("File uploaded:", uploaded_file.name)
    else:
        st.write("No file uploaded.")
    ```
    """
    uploaded_file = st.file_uploader("–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª")
    if uploaded_file is not None:
        return uploaded_file
    return None


def check_nulls(df):
    """
    Checks and summarizes the number and percentage of missing (null) values in each column of a pandas DataFrame.

    Parameters:
    - data (pd.DataFrame): The DataFrame to be analyzed for null values.

    Returns:
    - pd.DataFrame: A DataFrame with two columns: 'amount' which represents the count of null values per column,
      and 'percentage' which shows the percentage of null values per column, rounded to four decimal places and
      multiplied by 100 to convert to percentage format.
    """

    df_null = pd.DataFrame(
        {
            "Missing Values": df.isna().sum().values,
            "% of Total Values": 100 * df.isnull().sum() / len(df),
        },
        index=df.isna().sum().index,
    )
    df_null = df_null.sort_values("% of Total Values", ascending=False).round(2)
    # print ("Your selected dataframe has " + str(df.shape[1]) + " columns and " + str(df.shape[0]) + " Rows.\n"
    # "There are " + str(df_null.shape[0]) + " columns that have missing values.")
    return df_null


def delete_columns(data, columns):
    """
    Removes specified columns from a DataFrame.

    This function takes a DataFrame and a list of column names to be removed. It returns a new DataFrame with the specified
    columns removed, leaving the original DataFrame unchanged.

    Parameters:
    - data (pd.DataFrame): The original DataFrame from which columns will be removed.
    - columns (list of str): A list of strings representing the names of the columns to be removed.

    Returns:
    - pd.DataFrame: A new DataFrame with the specified columns removed.
    """
    dataframe = data.drop(columns, axis=1)
    return dataframe


def fill_numerical_data(data, columns):
    """
    Fills missing values in specified numerical columns with the median of each column.

    This function iterates over a list of columns in a DataFrame, filling in missing (NaN) values in those columns with
    the median of each respective column. The changes are made in place, but the DataFrame is also returned for convenience
    and chaining operations.

    Parameters:
    - data (pd.DataFrame): The DataFrame containing the columns to be filled.
    - columns (list of str): A list of column names (strings) in the DataFrame that are to be filled. These should be columns with numerical data.

    Returns:
    - pd.DataFrame: The original DataFrame with missing values in the specified columns filled with their respective medians.
    """
    for col in columns:
        data[col].fillna(data[col].median(), inplace=True)
    return data


def fill_categorical_data(data, columns):
    """
    Fills missing values in specified categorical columns with the most frequent value of each column.

    Utilizes the SimpleImputer class from sklearn.impute to fill missing (NaN) values in the DataFrame's categorical columns
    with the most frequent value (mode) found in each column. This operation updates the DataFrame in place and returns it
    for potential chaining of operations or further modifications.

    Parameters:
    - data (pd.DataFrame): The DataFrame containing the columns to be filled. It's expected to be modified in place.
    - columns (list of str): A list of column names (strings) that are to be treated, which should correspond to categorical data.

    Returns:
    - pd.DataFrame: The original DataFrame with missing values in the specified columns filled with their most frequent value.

    Note:
    - This function requires the sklearn library for the SimpleImputer class. Ensure sklearn is installed and imported correctly.
    """
    from sklearn.impute import SimpleImputer

    imputer = SimpleImputer(strategy="most_frequent")
    for col in columns:
        data[col] = imputer.fit_transform(data[[col]]).ravel()
    return data


def create_toggle(session_name: str, name: str, status=False) -> bool:
    """
    Creates a toggle switch in a Streamlit app and manages its state across reruns.

    This function displays a toggle switch with the label specified by the 'name' parameter.
    It uses Streamlit's session state to keep track of the toggle's position (on/off) across reruns.
    The current state of the toggle is stored in `st.session_state` using a key provided by the
    'session_name' parameter.

    Parameters:
    - session_name (str): The key used to store the toggle's state in `st.session_state`.
                          This key should be unique to each toggle to prevent state conflicts.
    - name (str): The label displayed next to the toggle switch in the UI.

    Returns:
    - bool: The current state of the toggle (True for on, False for off).

    Example:
    ```
    delete_column = create_toggle('delete_status', '–£–¥–∞–ª–∏—Ç—å')
    if delete_column:
        st.write("Toggle is ON - deletion logic can be placed here.")
    else:
        st.write("Toggle is OFF - no deletion occurs.")
    ```
    """
    # Initialize toggle status in session_state if it doesn't exist
    if session_name not in st.session_state:
        st.session_state[session_name] = False

    # Display the toggle and assign its current value based on session_state
    toggle = st.toggle(name, value=st.session_state[session_name], disabled=status)

    # Update session state based on the toggle's position
    if toggle != st.session_state[session_name]:
        st.session_state[session_name] = toggle
        st.rerun()
    return toggle


def apply_one_hot_encoder(df, columns):
    dataframe = pd.get_dummies(df, columns=columns, drop_first=True)
    return dataframe


def apply_label_encoder(df, columns):
    label_encoder = LabelEncoder()
    for column in columns:
        df[column] = label_encoder.fit_transform(df[column])
    return df


def apply_ordinal_encoder(df, columns):
    ordinal_encoder = OrdinalEncoder()
    for column in columns:
        # Ensure the column is in a 2D array format and fit_transform
        # Also, handling the case where column data might not be numeric
        df[column] = ordinal_encoder.fit_transform(df[[column]])
    return df


def reset_all_parameters_selection():
    st.session_state["all_parameters_selected"] = False


def apply_min_max_scaling(df, columns):
    scaler = MinMaxScaler()
    df[columns] = scaler.fit_transform(df[columns])
    return df


def apply_standardization(df, columns):
    scaler = StandardScaler()
    df[columns] = scaler.fit_transform(df[columns])
    return df


def apply_log_transformation(df, columns):
    # Apply log transformation with a small constant to avoid log(0)
    for column in columns:
        df[column] = np.log(df[column] + 1)
    return df


# def line_chart(data, x_axis, y_axis, plot_title=None, hue=None):
#     fig = px.line(data, x=x_axis, y=y_axis, title=plot_title, color=hue)
#     st.plotly_chart(fig, use_container_width=True)

# def scatter_plot(data, x_axis, y_axis, plot_title=None, hue=None):
#     fig = px.scatter(data, x=x_axis, y=y_axis, title=plot_title, color=hue)
#     st.plotly_chart(fig, use_container_width=True)


def line_chart(data, x_axis, y_axis, input_color_theme, hue=None):
    # If hue is provided, color the circles based on the hue column and the input color theme.
    # If hue is None, all circles will be colored red.
    if hue:
        color_encoding = alt.Color(hue, scale=alt.Scale(scheme=input_color_theme))
    else:
        color_encoding = alt.value(
            input_color_theme
        )  # Directly set the color to red if hue is not provided

    c = (
        alt.Chart(data)
        .mark_line()
        .encode(x=x_axis, y=y_axis, color=color_encoding)
        .interactive()
    )

    st.altair_chart(c, use_container_width=True)


def scatter_plot(data, x_axis, y_axis, input_color_theme, hue=None):
    # If hue is provided, color the circles based on the hue column and the input color theme.
    # If hue is None, all circles will be colored red.
    if hue:
        color_encoding = alt.Color(hue, scale=alt.Scale(scheme=input_color_theme))
    else:
        color_encoding = alt.value(
            input_color_theme
        )  # Directly set the color to red if hue is not provided

    c = (
        alt.Chart(data)
        .mark_circle()
        .encode(x=x_axis, y=y_axis, color=color_encoding)
        .interactive()
    )

    st.altair_chart(c, use_container_width=True)


import altair as alt
import streamlit as st


def histogram(data, x_axis, input_color_theme, hue=None):
    # If hue is provided, color the bars based on the hue column and the input color theme.
    # If hue is None, all bars will be colored with the input color theme.
    if hue:
        color_encoding = alt.Color(hue, scale=alt.Scale(scheme=input_color_theme))
    else:
        color_encoding = alt.value(
            input_color_theme
        )  # Directly set the color to red if hue is not provided

    chart = (
        alt.Chart(data)
        .mark_bar()
        .encode(x=alt.X(x_axis, bin=True), y="count()", color=color_encoding)
        .interactive()
    )

    st.altair_chart(chart, use_container_width=True)


def box_plot(data, x_axis, y_axis, input_color_theme, hue=None):
    # If hue is provided, color the box plot based on the hue column and the input color theme.
    # If hue is None, all plots will be colored with the input color theme.
    if hue:
        color_encoding = alt.Color(hue, scale=alt.Scale(scheme=input_color_theme))
    else:
        color_encoding = alt.value(
            input_color_theme
        )  # Directly set the color to red if hue is not provided

    chart = (
        alt.Chart(data)
        .mark_boxplot()
        .encode(x=x_axis, y=y_axis, color=color_encoding)
        .interactive()
    )

    st.altair_chart(chart, use_container_width=True)


def density_plot(data, x_axis, input_color_theme, hue=None):
    # Start with the base chart
    chart = alt.Chart(data)

    # Apply the density transformation conditionally based on hue
    if hue:
        # If hue is provided, calculate density with grouping
        chart = chart.transform_density(
            density=x_axis,
            as_=[x_axis, "density"],
            groupby=[hue],  # Ensure this is a list
        )
    else:
        # If hue is not provided, calculate density without grouping
        chart = chart.transform_density(density=x_axis, as_=[x_axis, "density"])

    # Apply the rest of the encoding
    chart = chart.mark_area().encode(
        x=f"{x_axis}:Q",
        y="density:Q",
        color=(
            alt.Color(hue, scale=alt.Scale(scheme=input_color_theme))
            if hue
            else alt.value(input_color_theme)
        ),
    )

    st.altair_chart(chart, use_container_width=True)


def custom_linear_regression():
    model = LinearRegression()
    return model


def custom_logistic_regression(C_c=1, n_jobs_c=-1, max_iter_c=100, l1_ratio_c=None):
    model = LogisticRegression(
        C=C_c, n_jobs=n_jobs_c, max_iter=max_iter_c, l1_ratio=l1_ratio_c
    )
    return model


def custom_decision_tree_regression(
    criterion_c="squared_error",
    max_depth_c=None,
    min_samples_split_c=2,
    min_samples_leaf_c=2,
    ccp_alpha_c=0.0,
):
    model = DecisionTreeRegressor(
        criterion=criterion_c,
        max_depth=max_depth_c,
        min_samples_split=min_samples_split_c,
        min_samples_leaf=min_samples_leaf_c,
        ccp_alpha=ccp_alpha_c,
    )
    return model


def custom_decision_tree_classification(
    criterion_c="gini",
    max_depth_c=None,
    min_samples_split_c=2,
    min_samples_leaf_c=2,
    ccp_alpha_c=0.0,
):
    model = DecisionTreeClassifier(
        criterion=criterion_c,
        max_depth=max_depth_c,
        min_samples_split=min_samples_split_c,
        min_samples_leaf=min_samples_leaf_c,
        ccp_alpha=ccp_alpha_c,
    )
    return model


def custom_train_test_split(X, y, size=0.2):
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=size)
    return X_train, X_test, y_train, y_test


def confusion_matrix_visualization(y_true, y_pred, input_color="Blues"):
    cm = confusion_matrix(y_true, y_pred)
    fig = plt.figure(figsize=(10, 10))
    sns.heatmap(cm, annot=True, fmt="d", cmap=input_color, cbar=False)
    plt.xlabel("Predicted labels")
    plt.ylabel("True labels")
    plt.title("Confusion Matrix")
    st.pyplot(fig)


def regression_result_visualization(y_true, y_pred, input_color):
    # Create a lmplot with seaborn. 'palette' should be a dictionary mapping levels of the hue variable to matplotlib colors.
    fig = plt.figure(figsize=(10, 6))
    plt.scatter(y_true, y_pred, c=input_color)

    st.pyplot(fig)


def correlation_matrix_visualize(data, color):
    fig = plt.figure(figsize=(15, 15))
    correlation = data.corr()
    sns.heatmap(correlation, annot=True, cmap=color, fmt=".2f")
    plt.title("Correlation of Features")

    st.pyplot(fig)


def train_and_predict(model, X_train, y_train, X_test):
    """
    Trains a model and predicts outcomes for the given test data.
    This function uses Streamlit's memoization to cache the model training and prediction steps,
    improving performance for repeated calls with unchanged data.

    Args:
        model: The machine learning model to be trained. Must be hashable by Streamlit.
        X_train (pd.DataFrame or np.ndarray): Training data features.
        y_train (pd.Series or np.ndarray): Training data labels/targets.
        X_test (pd.DataFrame or np.ndarray): Test data features.

    Returns:
        A tuple containing:
        - model: The trained machine learning model.
        - pred: Predictions made by the model on X_test.
    """
    model.fit(X_train, y_train)
    pred = model.predict(X_test)
    return model, pred


def custom_random_forest_regression(
    n_estimators_c=100,
    criterion_c="squared_error",
    max_depth_c=None,
    min_samples_split_c=2,
    min_samples_leaf_c=2,
    ccp_alpha_c=0.0,
):
    model = RandomForestRegressor(
        n_estimators=n_estimators_c,
        max_depth=max_depth_c,
        min_samples_split=min_samples_split_c,
        min_samples_leaf=min_samples_leaf_c,
        ccp_alpha=ccp_alpha_c,
    )
    return model


def custom_random_forest_classification(
    n_estimators_c=100,
    criterion_c="squared_error",
    max_depth_c=None,
    min_samples_split_c=2,
    min_samples_leaf_c=2,
    ccp_alpha_c=0.0,
):
    model = RandomForestClassifier(
        n_estimators=n_estimators_c,
        max_depth=max_depth_c,
        min_samples_split=min_samples_split_c,
        min_samples_leaf=min_samples_leaf_c,
        ccp_alpha=ccp_alpha_c,
    )
    return model


def custom_svr(kernel_c="rbf", degree_c=3):
    model = SVR(kernel=kernel_c, degree=degree_c)
    return model


def custom_svc(kernel_c="rbf", degree_c=3):
    model = SVC(kernel=kernel_c, degree=degree_c)
    return model


def custom_gbc(
    loss_c="log_loss",
    learning_rate_c=0.1,
    n_estimators_c=100,
    criterion_c="squared_error",
    max_depth_c=None,
    min_samples_split_c=2,
    min_samples_leaf_c=2,
    ccp_alpha_c=0.0,
):
    model = GradientBoostingClassifier(
        loss=loss_c,
        learning_rate=learning_rate_c,
        n_estimators=n_estimators_c,
        max_depth=max_depth_c,
        min_samples_split=min_samples_split_c,
        min_samples_leaf=min_samples_leaf_c,
        ccp_alpha=ccp_alpha_c,
    )
    return model


def custom_gbr(
    loss_c="squared_error",
    learning_rate_c=0.1,
    n_estimators_c=100,
    criterion_c="squared_error",
    max_depth_c=None,
    min_samples_split_c=2,
    min_samples_leaf_c=2,
    ccp_alpha_c=0.0,
):
    model = GradientBoostingRegressor(
        loss=loss_c,
        learning_rate=learning_rate_c,
        n_estimators=n_estimators_c,
        max_depth=max_depth_c,
        min_samples_split=min_samples_split_c,
        min_samples_leaf=min_samples_leaf_c,
        ccp_alpha=ccp_alpha_c,
    )
    return model


def custom_mlp_classifier(
    activation_func_c="relu",
    solver_c="adam",
    number_layers_c=100
):
    model = MLPClassifier(
        activation=activation_func_c,
        solver=solver_c,
        hidden_layer_sizes=number_layers_c,
    )
    return model

def custom_mlp_regressor(
    activation_func_c="relu",
    solver_c="adam",
):
    model = MLPRegressor(
        activation=activation_func_c,
        solver=solver_c
    )
    return model


if __name__ == "__main__":
    load_widget_state()
    main()
